# coding: utf-8

"""
    Control-M Services

    Provides access to BMC Control-M Services  # noqa: E501

    OpenAPI spec version: 9.21.340
    Contact: customer_support@bmc.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from controlm_py.api_client import ApiClient


class ConfigApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_agent(self, body, server, **kwargs):  # noqa: E501
        """add agent to Server  # noqa: E501

        Add an agent to Server. This command does not install or configure the agent. It only defines the agent in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_agent(body, server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddAgentParams body: (required)
        :param str server: The Server the agent is going to be added to. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_agent_with_http_info(body, server, **kwargs)  # noqa: E501
        else:
            (data) = self.add_agent_with_http_info(body, server, **kwargs)  # noqa: E501
            return data

    def add_agent_with_http_info(self, body, server, **kwargs):  # noqa: E501
        """add agent to Server  # noqa: E501

        Add an agent to Server. This command does not install or configure the agent. It only defines the agent in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_agent_with_http_info(body, server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddAgentParams body: (required)
        :param str server: The Server the agent is going to be added to. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_agent`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `add_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_agentless_host(self, server, **kwargs):  # noqa: E501
        """add agentless host to Server  # noqa: E501

        Add an agentless host to Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_agentless_host(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is going to be added to. (required)
        :param AddRemoteHostParams body: The non default, advanced configuration data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_agentless_host_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.add_agentless_host_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def add_agentless_host_with_http_info(self, server, **kwargs):  # noqa: E501
        """add agentless host to Server  # noqa: E501

        Add an agentless host to Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_agentless_host_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is going to be added to. (required)
        :param AddRemoteHostParams body: The non default, advanced configuration data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_agentless_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `add_agentless_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_archive_rule(self, body, **kwargs):  # noqa: E501
        """Add Workload Archiving rule  # noqa: E501

        Add a new Workload Archiving rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_archive_rule(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ArchiveRule body: archive rule details to add (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_archive_rule_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_archive_rule_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_archive_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add Workload Archiving rule  # noqa: E501

        Add a new Workload Archiving rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_archive_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ArchiveRule body: archive rule details to add (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_archive_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_archive_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/archive/rule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_external_user(self, body, **kwargs):  # noqa: E501
        """Add and external user  # noqa: E501

        Add and external user for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_external_user_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_external_user_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_external_user_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add and external user  # noqa: E501

        Add and external user for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_external_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_external_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externaluser', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_external_user_for_site(self, body, site_name, **kwargs):  # noqa: E501
        """Add and external user for site  # noqa: E501

        Add and external user for site for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_for_site(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :param str site_name: site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_external_user_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_external_user_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
            return data

    def add_external_user_for_site_with_http_info(self, body, site_name, **kwargs):  # noqa: E501
        """Add and external user for site  # noqa: E501

        Add and external user for site for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_for_site_with_http_info(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :param str site_name: site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_external_user_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_external_user_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_external_user_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externaluser', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_external_user_or_user_group_to_mft_folder(self, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Add external user or user groups to virtual folder external users list.  # noqa: E501

        Add external user user groups to virtual folder external users list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_or_user_group_to_mft_folder(folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name or group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_external_user_or_user_group_to_mft_folder_with_http_info(folder_name, user_or_group, **kwargs)  # noqa: E501
        else:
            (data) = self.add_external_user_or_user_group_to_mft_folder_with_http_info(folder_name, user_or_group, **kwargs)  # noqa: E501
            return data

    def add_external_user_or_user_group_to_mft_folder_with_http_info(self, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Add external user or user groups to virtual folder external users list.  # noqa: E501

        Add external user user groups to virtual folder external users list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_or_user_group_to_mft_folder_with_http_info(folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name or group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_name', 'user_or_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_external_user_or_user_group_to_mft_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `add_external_user_or_user_group_to_mft_folder`")  # noqa: E501
        # verify the required parameter 'user_or_group' is set
        if ('user_or_group' not in params or
                params['user_or_group'] is None):
            raise ValueError("Missing the required parameter `user_or_group` when calling `add_external_user_or_user_group_to_mft_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501
        if 'user_or_group' in params:
            path_params['userOrGroup'] = params['user_or_group']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/virtualfolder/{folderName}/user/{userOrGroup}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_external_user_or_user_group_to_mft_folder_for_site(self, site_name, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Add external user or user groups to virtual folder external users list for site.  # noqa: E501

        Add external user user groups to virtual folder external users list for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_or_user_group_to_mft_folder_for_site(site_name, folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name or group name (required)
        :param str access_level: Access level of user or group for specific folder
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_external_user_or_user_group_to_mft_folder_for_site_with_http_info(site_name, folder_name, user_or_group, **kwargs)  # noqa: E501
        else:
            (data) = self.add_external_user_or_user_group_to_mft_folder_for_site_with_http_info(site_name, folder_name, user_or_group, **kwargs)  # noqa: E501
            return data

    def add_external_user_or_user_group_to_mft_folder_for_site_with_http_info(self, site_name, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Add external user or user groups to virtual folder external users list for site.  # noqa: E501

        Add external user user groups to virtual folder external users list for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_or_user_group_to_mft_folder_for_site_with_http_info(site_name, folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name or group name (required)
        :param str access_level: Access level of user or group for specific folder
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'folder_name', 'user_or_group', 'access_level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_external_user_or_user_group_to_mft_folder_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_external_user_or_user_group_to_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `add_external_user_or_user_group_to_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'user_or_group' is set
        if ('user_or_group' not in params or
                params['user_or_group'] is None):
            raise ValueError("Missing the required parameter `user_or_group` when calling `add_external_user_or_user_group_to_mft_folder_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501
        if 'user_or_group' in params:
            path_params['userOrGroup'] = params['user_or_group']  # noqa: E501

        query_params = []
        if 'access_level' in params:
            query_params.append(('accessLevel', params['access_level']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/virtualfolder/{folderName}/user/{userOrGroup}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_external_user_to_mft_user_group_for_site(self, site_name, group_name, user_name, **kwargs):  # noqa: E501
        """Add external user to user groups for site.  # noqa: E501

        Add external user to user groups for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_to_mft_user_group_for_site(site_name, group_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group (required)
        :param str user_name: The user name (required)
        :return: UserGroupPropertiesData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_external_user_to_mft_user_group_for_site_with_http_info(site_name, group_name, user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_external_user_to_mft_user_group_for_site_with_http_info(site_name, group_name, user_name, **kwargs)  # noqa: E501
            return data

    def add_external_user_to_mft_user_group_for_site_with_http_info(self, site_name, group_name, user_name, **kwargs):  # noqa: E501
        """Add external user to user groups for site.  # noqa: E501

        Add external user to user groups for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_external_user_to_mft_user_group_for_site_with_http_info(site_name, group_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group (required)
        :param str user_name: The user name (required)
        :return: UserGroupPropertiesData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'group_name', 'user_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_external_user_to_mft_user_group_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_external_user_to_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'group_name' is set
        if ('group_name' not in params or
                params['group_name'] is None):
            raise ValueError("Missing the required parameter `group_name` when calling `add_external_user_to_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `add_external_user_to_mft_user_group_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'group_name' in params:
            path_params['groupName'] = params['group_name']  # noqa: E501
        if 'user_name' in params:
            path_params['userName'] = params['user_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroup/{groupName}/user/{userName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserGroupPropertiesData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_gateway(self, body, **kwargs):  # noqa: E501
        """add gateway.  # noqa: E501

        add gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_gateway(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GatewayData body: gateway data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_gateway_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_gateway_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_gateway_with_http_info(self, body, **kwargs):  # noqa: E501
        """add gateway.  # noqa: E501

        add gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_gateway_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GatewayData body: gateway data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_gateway" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_gateway`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/gateway', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_gateway_for_site(self, body, site_name, **kwargs):  # noqa: E501
        """add gateway for site.  # noqa: E501

        add gateway for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_gateway_for_site(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GatewayData body: gateway data (required)
        :param str site_name: site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_gateway_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_gateway_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
            return data

    def add_gateway_for_site_with_http_info(self, body, site_name, **kwargs):  # noqa: E501
        """add gateway for site.  # noqa: E501

        add gateway for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_gateway_for_site_with_http_info(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GatewayData body: gateway data (required)
        :param str site_name: site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_gateway_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_gateway_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_gateway_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/gateway', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_host_restriction(self, ctm, **kwargs):  # noqa: E501
        """Add new Host Restriction.  # noqa: E501

        Add new Host Restriction to the agent/s of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_host_restriction(ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param HostRestriction body: The Host Restrictions to add on the Agent/s
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_host_restriction_with_http_info(ctm, **kwargs)  # noqa: E501
        else:
            (data) = self.add_host_restriction_with_http_info(ctm, **kwargs)  # noqa: E501
            return data

    def add_host_restriction_with_http_info(self, ctm, **kwargs):  # noqa: E501
        """Add new Host Restriction.  # noqa: E501

        Add new Host Restriction to the agent/s of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_host_restriction_with_http_info(ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param HostRestriction body: The Host Restrictions to add on the Agent/s
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ctm', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_host_restriction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `add_host_restriction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/hostRestriction', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_host_to_hostgroup(self, body, server, hostgroup, **kwargs):  # noqa: E501
        """add agent to hostgroup  # noqa: E501

        Add an agent to hostgroup. Create the the hostgroup if it does not exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_host_to_hostgroup(body, server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AgentInHostgroup body: The hostname of the new agent (required)
        :param str server: The Server the hostgroup belongs to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: AgentsInGroupSuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_host_to_hostgroup_with_http_info(body, server, hostgroup, **kwargs)  # noqa: E501
        else:
            (data) = self.add_host_to_hostgroup_with_http_info(body, server, hostgroup, **kwargs)  # noqa: E501
            return data

    def add_host_to_hostgroup_with_http_info(self, body, server, hostgroup, **kwargs):  # noqa: E501
        """add agent to hostgroup  # noqa: E501

        Add an agent to hostgroup. Create the the hostgroup if it does not exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_host_to_hostgroup_with_http_info(body, server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AgentInHostgroup body: The hostname of the new agent (required)
        :param str server: The Server the hostgroup belongs to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: AgentsInGroupSuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'hostgroup']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_host_to_hostgroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_host_to_hostgroup`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `add_host_to_hostgroup`")  # noqa: E501
        # verify the required parameter 'hostgroup' is set
        if ('hostgroup' not in params or
                params['hostgroup'] is None):
            raise ValueError("Missing the required parameter `hostgroup` when calling `add_host_to_hostgroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'hostgroup' in params:
            path_params['hostgroup'] = params['hostgroup']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/hostgroup/{hostgroup}/agent', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AgentsInGroupSuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_hub_to_cluster(self, agentname, **kwargs):  # noqa: E501
        """add hub to cluster.  # noqa: E501

        add hub to cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_hub_to_cluster(agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_hub_to_cluster_with_http_info(agentname, **kwargs)  # noqa: E501
        else:
            (data) = self.add_hub_to_cluster_with_http_info(agentname, **kwargs)  # noqa: E501
            return data

    def add_hub_to_cluster_with_http_info(self, agentname, **kwargs):  # noqa: E501
        """add hub to cluster.  # noqa: E501

        add hub to cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_hub_to_cluster_with_http_info(agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agentname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_hub_to_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agentname' is set
        if ('agentname' not in params or
                params['agentname'] is None):
            raise ValueError("Missing the required parameter `agentname` when calling `add_hub_to_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agentname' in params:
            path_params['agentname'] = params['agentname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/cluster/hub/{agentname}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_hub_to_cluster_for_site(self, site_name, agentname, **kwargs):  # noqa: E501
        """add hub to cluster for site.  # noqa: E501

        add hub to cluster for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_hub_to_cluster_for_site(site_name, agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_hub_to_cluster_for_site_with_http_info(site_name, agentname, **kwargs)  # noqa: E501
        else:
            (data) = self.add_hub_to_cluster_for_site_with_http_info(site_name, agentname, **kwargs)  # noqa: E501
            return data

    def add_hub_to_cluster_for_site_with_http_info(self, site_name, agentname, **kwargs):  # noqa: E501
        """add hub to cluster for site.  # noqa: E501

        add hub to cluster for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_hub_to_cluster_for_site_with_http_info(site_name, agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'agentname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_hub_to_cluster_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_hub_to_cluster_for_site`")  # noqa: E501
        # verify the required parameter 'agentname' is set
        if ('agentname' not in params or
                params['agentname'] is None):
            raise ValueError("Missing the required parameter `agentname` when calling `add_hub_to_cluster_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'agentname' in params:
            path_params['agentname'] = params['agentname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/cluster/hub/{agentname}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_ldap_group_to_mft_user_group_for_site(self, site_name, group_name, ldap_group_name, **kwargs):  # noqa: E501
        """Add LDAP group to group for site.  # noqa: E501

        Add LDAP group to group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ldap_group_to_mft_user_group_for_site(site_name, group_name, ldap_group_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group. (required)
        :param str ldap_group_name: The LDAP group name. (required)
        :return: UserGroupPropertiesData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_ldap_group_to_mft_user_group_for_site_with_http_info(site_name, group_name, ldap_group_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ldap_group_to_mft_user_group_for_site_with_http_info(site_name, group_name, ldap_group_name, **kwargs)  # noqa: E501
            return data

    def add_ldap_group_to_mft_user_group_for_site_with_http_info(self, site_name, group_name, ldap_group_name, **kwargs):  # noqa: E501
        """Add LDAP group to group for site.  # noqa: E501

        Add LDAP group to group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ldap_group_to_mft_user_group_for_site_with_http_info(site_name, group_name, ldap_group_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group. (required)
        :param str ldap_group_name: The LDAP group name. (required)
        :return: UserGroupPropertiesData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'group_name', 'ldap_group_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ldap_group_to_mft_user_group_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_ldap_group_to_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'group_name' is set
        if ('group_name' not in params or
                params['group_name'] is None):
            raise ValueError("Missing the required parameter `group_name` when calling `add_ldap_group_to_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'ldap_group_name' is set
        if ('ldap_group_name' not in params or
                params['ldap_group_name'] is None):
            raise ValueError("Missing the required parameter `ldap_group_name` when calling `add_ldap_group_to_mft_user_group_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'group_name' in params:
            path_params['groupName'] = params['group_name']  # noqa: E501
        if 'ldap_group_name' in params:
            path_params['ldapGroupName'] = params['ldap_group_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroup/{groupName}/ldapGroup/{ldapGroupName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserGroupPropertiesData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_mft_folder(self, body, **kwargs):  # noqa: E501
        """Add virtual folder  # noqa: E501

        Add virtual folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_folder(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_mft_folder_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_mft_folder_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_mft_folder_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add virtual folder  # noqa: E501

        Add virtual folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_folder_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_mft_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_mft_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/virtualfolder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_mft_folder_for_site(self, body, site_name, **kwargs):  # noqa: E501
        """Add virtual folder for site  # noqa: E501

        Add virtual folder for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_folder_for_site(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :param str site_name: The site name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_mft_folder_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_mft_folder_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
            return data

    def add_mft_folder_for_site_with_http_info(self, body, site_name, **kwargs):  # noqa: E501
        """Add virtual folder for site  # noqa: E501

        Add virtual folder for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_folder_for_site_with_http_info(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :param str site_name: The site name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_mft_folder_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_mft_folder_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/virtualfolder', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_mft_processing_rule_for_site(self, rule_properties_file, site_name, **kwargs):  # noqa: E501
        """Add MFTE processing rule for site  # noqa: E501

        Add MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_processing_rule_for_site(rule_properties_file, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_properties_file: (required)
        :param str site_name: site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_mft_processing_rule_for_site_with_http_info(rule_properties_file, site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_mft_processing_rule_for_site_with_http_info(rule_properties_file, site_name, **kwargs)  # noqa: E501
            return data

    def add_mft_processing_rule_for_site_with_http_info(self, rule_properties_file, site_name, **kwargs):  # noqa: E501
        """Add MFTE processing rule for site  # noqa: E501

        Add MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_processing_rule_for_site_with_http_info(rule_properties_file, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_properties_file: (required)
        :param str site_name: site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_properties_file', 'site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_mft_processing_rule_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_properties_file' is set
        if ('rule_properties_file' not in params or
                params['rule_properties_file'] is None):
            raise ValueError("Missing the required parameter `rule_properties_file` when calling `add_mft_processing_rule_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_mft_processing_rule_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'rule_properties_file' in params:
            local_var_files['rulePropertiesFile'] = params['rule_properties_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/processingRule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_mft_user_group(self, body, **kwargs):  # noqa: E501
        """Add user group.  # noqa: E501

        Add user group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_user_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupPropertiesData body: User group object properites (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_mft_user_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_mft_user_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_mft_user_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add user group.  # noqa: E501

        Add user group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_user_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupPropertiesData body: User group object properites (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_mft_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_mft_user_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/usergroup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_mft_user_group_for_site(self, body, site_name, **kwargs):  # noqa: E501
        """Add user group for site.  # noqa: E501

        Add user group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_user_group_for_site(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupPropertiesData body: User group object properites (required)
        :param str site_name: The site name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_mft_user_group_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_mft_user_group_for_site_with_http_info(body, site_name, **kwargs)  # noqa: E501
            return data

    def add_mft_user_group_for_site_with_http_info(self, body, site_name, **kwargs):  # noqa: E501
        """Add user group for site.  # noqa: E501

        Add user group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_mft_user_group_for_site_with_http_info(body, site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupPropertiesData body: User group object properites (required)
        :param str site_name: The site name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_mft_user_group_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `add_mft_user_group_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pgp_template(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Add PGP Template  # noqa: E501

        Add PGP Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pgp_template(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PgpTemplateData body: PGP Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The PGP Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pgp_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pgp_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
            return data

    def add_pgp_template_with_http_info(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Add PGP Template  # noqa: E501

        Add PGP Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pgp_template_with_http_info(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PgpTemplateData body: PGP Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The PGP Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent', 'template_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pgp_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_pgp_template`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `add_pgp_template`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `add_pgp_template`")  # noqa: E501
        # verify the required parameter 'template_name' is set
        if ('template_name' not in params or
                params['template_name'] is None):
            raise ValueError("Missing the required parameter `template_name` when calling `add_pgp_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'template_name' in params:
            path_params['templateName'] = params['template_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/pgptemplate/{templateName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_remote_host(self, server, **kwargs):  # noqa: E501
        """add remote host to Server  # noqa: E501

        Add a remote host to Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_remote_host(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host is going to be added to. (required)
        :param AddRemoteHostParams body: The non default, advanced configuration data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_remote_host_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.add_remote_host_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def add_remote_host_with_http_info(self, server, **kwargs):  # noqa: E501
        """add remote host to Server  # noqa: E501

        Add a remote host to Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_remote_host_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host is going to be added to. (required)
        :param AddRemoteHostParams body: The non default, advanced configuration data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_remote_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `add_remote_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/remotehost', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_role(self, role_file, **kwargs):  # noqa: E501
        """Add Authorization Role  # noqa: E501

        Add Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role(role_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role_file: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_role_with_http_info(role_file, **kwargs)  # noqa: E501
        else:
            (data) = self.add_role_with_http_info(role_file, **kwargs)  # noqa: E501
            return data

    def add_role_with_http_info(self, role_file, **kwargs):  # noqa: E501
        """Add Authorization Role  # noqa: E501

        Add Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role_with_http_info(role_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role_file: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['role_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'role_file' is set
        if ('role_file' not in params or
                params['role_file'] is None):
            raise ValueError("Missing the required parameter `role_file` when calling `add_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'role_file' in params:
            local_var_files['roleFile'] = params['role_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/role', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_role_to_ldap_group(self, ldapgroup, role, **kwargs):  # noqa: E501
        """Add a role to LDAP group  # noqa: E501

        Add a role to LDAP group so any user belong to the LDAP group will get all permissions defined in the role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role_to_ldap_group(ldapgroup, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ldapgroup: Name of LDAP group (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_role_to_ldap_group_with_http_info(ldapgroup, role, **kwargs)  # noqa: E501
        else:
            (data) = self.add_role_to_ldap_group_with_http_info(ldapgroup, role, **kwargs)  # noqa: E501
            return data

    def add_role_to_ldap_group_with_http_info(self, ldapgroup, role, **kwargs):  # noqa: E501
        """Add a role to LDAP group  # noqa: E501

        Add a role to LDAP group so any user belong to the LDAP group will get all permissions defined in the role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role_to_ldap_group_with_http_info(ldapgroup, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ldapgroup: Name of LDAP group (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapgroup', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_role_to_ldap_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ldapgroup' is set
        if ('ldapgroup' not in params or
                params['ldapgroup'] is None):
            raise ValueError("Missing the required parameter `ldapgroup` when calling `add_role_to_ldap_group`")  # noqa: E501
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `add_role_to_ldap_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ldapgroup' in params:
            path_params['ldapgroup'] = params['ldapgroup']  # noqa: E501
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/ldap/{ldapgroup}/role/{role}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_role_to_user(self, user, role, **kwargs):  # noqa: E501
        """Add a role to user  # noqa: E501

        Add a role to user so that user will inherit role authorization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role_to_user(user, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Name of user (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_role_to_user_with_http_info(user, role, **kwargs)  # noqa: E501
        else:
            (data) = self.add_role_to_user_with_http_info(user, role, **kwargs)  # noqa: E501
            return data

    def add_role_to_user_with_http_info(self, user, role, **kwargs):  # noqa: E501
        """Add a role to user  # noqa: E501

        Add a role to user so that user will inherit role authorization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role_to_user_with_http_info(user, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Name of user (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_role_to_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `add_role_to_user`")  # noqa: E501
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `add_role_to_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/{user}/role/{role}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_secret(self, body, **kwargs):  # noqa: E501
        """Add a new secret  # noqa: E501

        Add a new secret to the secrets vault.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_secret(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecretKeyValue body: The new secret value (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_secret_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_secret_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_secret_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add a new secret  # noqa: E501

        Add a new secret to the secrets vault.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_secret_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SecretKeyValue body: The new secret value (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_secret`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/secret', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_server(self, body, **kwargs):  # noqa: E501
        """Discover and add server to the system  # noqa: E501

        Discover and add a Server. This command setting up new server in the system by automatic discover parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_server(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddServerParams body: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_server_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_server_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_server_with_http_info(self, body, **kwargs):  # noqa: E501
        """Discover and add server to the system  # noqa: E501

        Discover and add a Server. This command setting up new server in the system by automatic discover parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_server_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddServerParams body: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_ssh_key(self, body, ctm, **kwargs):  # noqa: E501
        """Add an SSH key to the control-m server.  # noqa: E501

        Add an SSH key to the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ssh_key(body, ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SSHKeyData body: The parameters of the ssh key name password type format bits. (required)
        :param str ctm: Name of the Control-M/Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_ssh_key_with_http_info(body, ctm, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ssh_key_with_http_info(body, ctm, **kwargs)  # noqa: E501
            return data

    def add_ssh_key_with_http_info(self, body, ctm, **kwargs):  # noqa: E501
        """Add an SSH key to the control-m server.  # noqa: E501

        Add an SSH key to the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ssh_key_with_http_info(body, ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SSHKeyData body: The parameters of the ssh key name password type format bits. (required)
        :param str ctm: Name of the Control-M/Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ctm']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ssh_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_ssh_key`")  # noqa: E501
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `add_ssh_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/sshkey/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_user(self, user_file, **kwargs):  # noqa: E501
        """Add user  # noqa: E501

        Add user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user(user_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_file: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_user_with_http_info(user_file, **kwargs)  # noqa: E501
        else:
            (data) = self.add_user_with_http_info(user_file, **kwargs)  # noqa: E501
            return data

    def add_user_with_http_info(self, user_file, **kwargs):  # noqa: E501
        """Add user  # noqa: E501

        Add user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user_with_http_info(user_file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_file: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_file' is set
        if ('user_file' not in params or
                params['user_file'] is None):
            raise ValueError("Missing the required parameter `user_file` when calling `add_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'user_file' in params:
            local_var_files['userFile'] = params['user_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_wda_gateway(self, body, server, agent, **kwargs):  # noqa: E501
        """add DataAssurance gateway.  # noqa: E501

        add DataAssurance gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_wda_gateway(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataAssuranceGatewayData body: DataAssurance Gateway Data (required)
        :param str server: server name (required)
        :param str agent: agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_wda_gateway_with_http_info(body, server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.add_wda_gateway_with_http_info(body, server, agent, **kwargs)  # noqa: E501
            return data

    def add_wda_gateway_with_http_info(self, body, server, agent, **kwargs):  # noqa: E501
        """add DataAssurance gateway.  # noqa: E501

        add DataAssurance gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_wda_gateway_with_http_info(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataAssuranceGatewayData body: DataAssurance Gateway Data (required)
        :param str server: server name (required)
        :param str agent: agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_wda_gateway" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_wda_gateway`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `add_wda_gateway`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `add_wda_gateway`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/dataAssurance/{server}/{agent}/gateway', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_zos_template(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Add z/OS Template  # noqa: E501

        Add z/OS Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_zos_template(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ZosTemplateData body: z/OS Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The z/OS Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_zos_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_zos_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
            return data

    def add_zos_template_with_http_info(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Add z/OS Template  # noqa: E501

        Add z/OS Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_zos_template_with_http_info(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ZosTemplateData body: z/OS Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The z/OS Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent', 'template_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_zos_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_zos_template`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `add_zos_template`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `add_zos_template`")  # noqa: E501
        # verify the required parameter 'template_name' is set
        if ('template_name' not in params or
                params['template_name'] is None):
            raise ValueError("Missing the required parameter `template_name` when calling `add_zos_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'template_name' in params:
            path_params['templateName'] = params['template_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/zostemplate/{templateName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def authorize_mft_ssh_cluster(self, body, server, agent, cluster_name, **kwargs):  # noqa: E501
        """Authorize SSH Cluster  # noqa: E501

        Authorize SSH Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_mft_ssh_cluster(body, server, agent, cluster_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterAuthorizationData body: File with content of hostnames and ports (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str cluster_name: Ssh Cluster Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.authorize_mft_ssh_cluster_with_http_info(body, server, agent, cluster_name, **kwargs)  # noqa: E501
        else:
            (data) = self.authorize_mft_ssh_cluster_with_http_info(body, server, agent, cluster_name, **kwargs)  # noqa: E501
            return data

    def authorize_mft_ssh_cluster_with_http_info(self, body, server, agent, cluster_name, **kwargs):  # noqa: E501
        """Authorize SSH Cluster  # noqa: E501

        Authorize SSH Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_mft_ssh_cluster_with_http_info(body, server, agent, cluster_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClusterAuthorizationData body: File with content of hostnames and ports (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str cluster_name: Ssh Cluster Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent', 'cluster_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_mft_ssh_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `authorize_mft_ssh_cluster`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `authorize_mft_ssh_cluster`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `authorize_mft_ssh_cluster`")  # noqa: E501
        # verify the required parameter 'cluster_name' is set
        if ('cluster_name' not in params or
                params['cluster_name'] is None):
            raise ValueError("Missing the required parameter `cluster_name` when calling `authorize_mft_ssh_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'cluster_name' in params:
            path_params['clusterName'] = params['cluster_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/ssh/cluster/{clusterName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def authorize_mft_ssh_host(self, server, agent, hostname, **kwargs):  # noqa: E501
        """Authorize SSH Host  # noqa: E501

        Authorize SSH Host for SFTP account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_mft_ssh_host(server, agent, hostname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str hostname: Ssh Hostname (required)
        :param str port: Ssh port for the relevant host
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.authorize_mft_ssh_host_with_http_info(server, agent, hostname, **kwargs)  # noqa: E501
        else:
            (data) = self.authorize_mft_ssh_host_with_http_info(server, agent, hostname, **kwargs)  # noqa: E501
            return data

    def authorize_mft_ssh_host_with_http_info(self, server, agent, hostname, **kwargs):  # noqa: E501
        """Authorize SSH Host  # noqa: E501

        Authorize SSH Host for SFTP account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_mft_ssh_host_with_http_info(server, agent, hostname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str hostname: Ssh Hostname (required)
        :param str port: Ssh port for the relevant host
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'hostname', 'port']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_mft_ssh_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `authorize_mft_ssh_host`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `authorize_mft_ssh_host`")  # noqa: E501
        # verify the required parameter 'hostname' is set
        if ('hostname' not in params or
                params['hostname'] is None):
            raise ValueError("Missing the required parameter `hostname` when calling `authorize_mft_ssh_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'hostname' in params:
            path_params['hostname'] = params['hostname']  # noqa: E501

        query_params = []
        if 'port' in params:
            query_params.append(('port', params['port']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/ssh/host/{hostname}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def authorize_ssh_known_agentlesshost(self, server, agentlesshost, **kwargs):  # noqa: E501
        """Authorize  # noqa: E501

        Authorized known ssh agentless host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_ssh_known_agentlesshost(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected to. (required)
        :param str agentlesshost: The name of the agentless host. (required)
        :param AuthorizeSSHData body: The data of the authorize ssh request
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.authorize_ssh_known_agentlesshost_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.authorize_ssh_known_agentlesshost_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def authorize_ssh_known_agentlesshost_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """Authorize  # noqa: E501

        Authorized known ssh agentless host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_ssh_known_agentlesshost_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected to. (required)
        :param str agentlesshost: The name of the agentless host. (required)
        :param AuthorizeSSHData body: The data of the authorize ssh request
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_ssh_known_agentlesshost" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `authorize_ssh_known_agentlesshost`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `authorize_ssh_known_agentlesshost`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}/authorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def authorize_ssh_known_remotehost(self, server, remotehost, **kwargs):  # noqa: E501
        """Authorize  # noqa: E501

        Authorized known ssh remote host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_ssh_known_remotehost(server, remotehost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host is connected to. (required)
        :param str remotehost: The name of the remote host. (required)
        :param str associated_agent: Optionally case insensitive agent name of host or alias of the Agent.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.authorize_ssh_known_remotehost_with_http_info(server, remotehost, **kwargs)  # noqa: E501
        else:
            (data) = self.authorize_ssh_known_remotehost_with_http_info(server, remotehost, **kwargs)  # noqa: E501
            return data

    def authorize_ssh_known_remotehost_with_http_info(self, server, remotehost, **kwargs):  # noqa: E501
        """Authorize  # noqa: E501

        Authorized known ssh remote host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_ssh_known_remotehost_with_http_info(server, remotehost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host is connected to. (required)
        :param str remotehost: The name of the remote host. (required)
        :param str associated_agent: Optionally case insensitive agent name of host or alias of the Agent.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'remotehost', 'associated_agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_ssh_known_remotehost" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `authorize_ssh_known_remotehost`")  # noqa: E501
        # verify the required parameter 'remotehost' is set
        if ('remotehost' not in params or
                params['remotehost'] is None):
            raise ValueError("Missing the required parameter `remotehost` when calling `authorize_ssh_known_remotehost`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'remotehost' in params:
            path_params['remotehost'] = params['remotehost']  # noqa: E501

        query_params = []
        if 'associated_agent' in params:
            query_params.append(('associatedAgent', params['associated_agent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/remotehost/{remotehost}/authorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_user_password(self, user, **kwargs):  # noqa: E501
        """Change user password  # noqa: E501

        Change user password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_user_password(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: user name (required)
        :param UserPassword body: The new password.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_user_password_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.change_user_password_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def change_user_password_with_http_info(self, user, **kwargs):  # noqa: E501
        """Change user password  # noqa: E501

        Change user password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_user_password_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: user name (required)
        :param UserPassword body: The new password.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_user_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `change_user_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/user/{user}/password/adminUpdate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_agent_certificate_signing_request(self, body, server, agent, **kwargs):  # noqa: E501
        """Create certificate signing request (CSR).  # noqa: E501

        Create certificate signing request (CSR) on SSL configured Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_agent_certificate_signing_request(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CertificateSigningRequestData body: Certificate Signing Request (CSR) data (required)
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_agent_certificate_signing_request_with_http_info(body, server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.create_agent_certificate_signing_request_with_http_info(body, server, agent, **kwargs)  # noqa: E501
            return data

    def create_agent_certificate_signing_request_with_http_info(self, body, server, agent, **kwargs):  # noqa: E501
        """Create certificate signing request (CSR).  # noqa: E501

        Create certificate signing request (CSR) on SSL configured Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_agent_certificate_signing_request_with_http_info(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CertificateSigningRequestData body: Certificate Signing Request (CSR) data (required)
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_agent_certificate_signing_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_agent_certificate_signing_request`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `create_agent_certificate_signing_request`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `create_agent_certificate_signing_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/csr', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_gateway(self, **kwargs):  # noqa: E501
        """Add gateway for server.  # noqa: E501

        Add gateway for server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_gateway(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddGatewayParams body: Gateway parameters
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_gateway_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_gateway_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_gateway_with_http_info(self, **kwargs):  # noqa: E501
        """Add gateway for server.  # noqa: E501

        Add gateway for server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_gateway_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddGatewayParams body: Gateway parameters
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_gateway" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/gateway', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_run_as_user(self, body, server, **kwargs):  # noqa: E501
        """Add a new Run-as user  # noqa: E501

        Add a new Run-as user to server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_as_user(body, server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunAsUserData body: Run as user data (required)
        :param str server: The Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_run_as_user_with_http_info(body, server, **kwargs)  # noqa: E501
        else:
            (data) = self.create_run_as_user_with_http_info(body, server, **kwargs)  # noqa: E501
            return data

    def create_run_as_user_with_http_info(self, body, server, **kwargs):  # noqa: E501
        """Add a new Run-as user  # noqa: E501

        Add a new Run-as user to server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_run_as_user_with_http_info(body, server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunAsUserData body: Run as user data (required)
        :param str server: The Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_run_as_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_run_as_user`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `create_run_as_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/runasuser', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ctm_pause(self, server, **kwargs):  # noqa: E501
        """Pause the CTM server.  # noqa: E501

        When server is paused, the server is still up and running but do not execute new jobs. Any jobs that are already executing will continue to be.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ctm_pause(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ctm_pause_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.ctm_pause_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def ctm_pause_with_http_info(self, server, **kwargs):  # noqa: E501
        """Pause the CTM server.  # noqa: E501

        When server is paused, the server is still up and running but do not execute new jobs. Any jobs that are already executing will continue to be.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ctm_pause_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ctm_pause" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `ctm_pause`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/pause', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ctm_server_rename(self, body, ctm_name, **kwargs):  # noqa: E501
        """CTM Server Rename.  # noqa: E501

        CTM Server Rename request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ctm_server_rename(body, ctm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CtmServerRenameParams body: CTM Server Rename parameters (required)
        :param str ctm_name: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ctm_server_rename_with_http_info(body, ctm_name, **kwargs)  # noqa: E501
        else:
            (data) = self.ctm_server_rename_with_http_info(body, ctm_name, **kwargs)  # noqa: E501
            return data

    def ctm_server_rename_with_http_info(self, body, ctm_name, **kwargs):  # noqa: E501
        """CTM Server Rename.  # noqa: E501

        CTM Server Rename request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ctm_server_rename_with_http_info(body, ctm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CtmServerRenameParams body: CTM Server Rename parameters (required)
        :param str ctm_name: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ctm_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ctm_server_rename" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ctm_server_rename`")  # noqa: E501
        # verify the required parameter 'ctm_name' is set
        if ('ctm_name' not in params or
                params['ctm_name'] is None):
            raise ValueError("Missing the required parameter `ctm_name` when calling `ctm_server_rename`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm_name' in params:
            path_params['ctmName'] = params['ctm_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctmName}/rename', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ctm_server_rename_preview(self, body, ctm_name, **kwargs):  # noqa: E501
        """CTM Server Rename Preview.  # noqa: E501

        CTM Server Rename Preview for generate Warnings report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ctm_server_rename_preview(body, ctm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CtmServerRenameParams body: CTM Server Rename Preview parameters (required)
        :param str ctm_name: (required)
        :return: CtmServerRenameReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ctm_server_rename_preview_with_http_info(body, ctm_name, **kwargs)  # noqa: E501
        else:
            (data) = self.ctm_server_rename_preview_with_http_info(body, ctm_name, **kwargs)  # noqa: E501
            return data

    def ctm_server_rename_preview_with_http_info(self, body, ctm_name, **kwargs):  # noqa: E501
        """CTM Server Rename Preview.  # noqa: E501

        CTM Server Rename Preview for generate Warnings report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ctm_server_rename_preview_with_http_info(body, ctm_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CtmServerRenameParams body: CTM Server Rename Preview parameters (required)
        :param str ctm_name: (required)
        :return: CtmServerRenameReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ctm_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ctm_server_rename_preview" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ctm_server_rename_preview`")  # noqa: E501
        # verify the required parameter 'ctm_name' is set
        if ('ctm_name' not in params or
                params['ctm_name'] is None):
            raise ValueError("Missing the required parameter `ctm_name` when calling `ctm_server_rename_preview`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm_name' in params:
            path_params['ctmName'] = params['ctm_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctmName}/rename/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CtmServerRenameReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def database_to_sync_mode(self, server, **kwargs):  # noqa: E501
        """Perform Control-M/Server Trigger DB sync mode  # noqa: E501

        Perform Control-M/Server Trigger DB sync mode on a specified Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.database_to_sync_mode(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.database_to_sync_mode_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.database_to_sync_mode_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def database_to_sync_mode_with_http_info(self, server, **kwargs):  # noqa: E501
        """Perform Control-M/Server Trigger DB sync mode  # noqa: E501

        Perform Control-M/Server Trigger DB sync mode on a specified Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.database_to_sync_mode_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method database_to_sync_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `database_to_sync_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/database/sync', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def define_server(self, body, **kwargs):  # noqa: E501
        """add server definition to the system  # noqa: E501

        Define a Server. This command setting up new server in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.define_server(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServerDefinitionParams body: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.define_server_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.define_server_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def define_server_with_http_info(self, body, **kwargs):  # noqa: E501
        """add server definition to the system  # noqa: E501

        Define a Server. This command setting up new server in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.define_server_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServerDefinitionParams body: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method define_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `define_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/define', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_agent(self, server, agent, **kwargs):  # noqa: E501
        """delete an agent from Server  # noqa: E501

        Delete an agent from a Server. This will not shut the agent down. It only disconnects and removes it from the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_agent(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to delete. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def delete_agent_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """delete an agent from Server  # noqa: E501

        Delete an agent from a Server. This will not shut the agent down. It only disconnects and removes it from the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_agent_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to delete. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_agent`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `delete_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_agentless_host(self, server, agentlesshost, **kwargs):  # noqa: E501
        """delete an agentless host from Server  # noqa: E501

        Delete an agentless host from a Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_agentless_host(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected to. (required)
        :param str agentlesshost: The name of the agentless host to delete. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def delete_agentless_host_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """delete an agentless host from Server  # noqa: E501

        Delete an agentless host from a Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_agentless_host_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected to. (required)
        :param str agentlesshost: The name of the agentless host to delete. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_agentless_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_agentless_host`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `delete_agentless_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_archive_rule(self, rule_name, delete_rule_data_flag, **kwargs):  # noqa: E501
        """Delete Workload Archiving rule  # noqa: E501

        Deletes Workload Archiving rule by name. It is required to send deleteRuleData flag to specify if rule need to be deleted with all the collected data or deleteRuleWithoutData otherwise.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_archive_rule(rule_name, delete_rule_data_flag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_name: Rule name to delete (required)
        :param str delete_rule_data_flag: Remove rule with collected data or without. REQUIRED. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_archive_rule_with_http_info(rule_name, delete_rule_data_flag, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_archive_rule_with_http_info(rule_name, delete_rule_data_flag, **kwargs)  # noqa: E501
            return data

    def delete_archive_rule_with_http_info(self, rule_name, delete_rule_data_flag, **kwargs):  # noqa: E501
        """Delete Workload Archiving rule  # noqa: E501

        Deletes Workload Archiving rule by name. It is required to send deleteRuleData flag to specify if rule need to be deleted with all the collected data or deleteRuleWithoutData otherwise.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_archive_rule_with_http_info(rule_name, delete_rule_data_flag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_name: Rule name to delete (required)
        :param str delete_rule_data_flag: Remove rule with collected data or without. REQUIRED. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_name', 'delete_rule_data_flag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_archive_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_name' is set
        if ('rule_name' not in params or
                params['rule_name'] is None):
            raise ValueError("Missing the required parameter `rule_name` when calling `delete_archive_rule`")  # noqa: E501
        # verify the required parameter 'delete_rule_data_flag' is set
        if ('delete_rule_data_flag' not in params or
                params['delete_rule_data_flag'] is None):
            raise ValueError("Missing the required parameter `delete_rule_data_flag` when calling `delete_archive_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_name' in params:
            path_params['ruleName'] = params['rule_name']  # noqa: E501

        query_params = []
        if 'delete_rule_data_flag' in params:
            query_params.append(('deleteRuleDataFlag', params['delete_rule_data_flag']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/archive/rule/{ruleName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_authorization_role(self, role, **kwargs):  # noqa: E501
        """Delete Authorization Role  # noqa: E501

        Delete Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_authorization_role(role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: The Role name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_authorization_role_with_http_info(role, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_authorization_role_with_http_info(role, **kwargs)  # noqa: E501
            return data

    def delete_authorization_role_with_http_info(self, role, **kwargs):  # noqa: E501
        """Delete Authorization Role  # noqa: E501

        Delete Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_authorization_role_with_http_info(role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: The Role name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_authorization_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `delete_authorization_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/role/{role}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_external_user(self, username, **kwargs):  # noqa: E501
        """Delete an external user  # noqa: E501

        Delete an existing external user in MFT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: The name of the external user to delete (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_external_user_with_http_info(username, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_external_user_with_http_info(username, **kwargs)  # noqa: E501
            return data

    def delete_external_user_with_http_info(self, username, **kwargs):  # noqa: E501
        """Delete an external user  # noqa: E501

        Delete an existing external user in MFT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: The name of the external user to delete (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_external_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `delete_external_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externaluser/{username}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_external_user_for_site(self, site_name, username, **kwargs):  # noqa: E501
        """Delete an external user from site  # noqa: E501

        Delete an existing external user from site in MFT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_for_site(site_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str username: The name of the external user to delete (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_external_user_for_site_with_http_info(site_name, username, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_external_user_for_site_with_http_info(site_name, username, **kwargs)  # noqa: E501
            return data

    def delete_external_user_for_site_with_http_info(self, site_name, username, **kwargs):  # noqa: E501
        """Delete an external user from site  # noqa: E501

        Delete an existing external user from site in MFT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_for_site_with_http_info(site_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str username: The name of the external user to delete (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'username']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_external_user_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `delete_external_user_for_site`")  # noqa: E501
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `delete_external_user_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'username' in params:
            path_params['username'] = params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externaluser/{username}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_external_user_from_mft_user_group_for_site(self, site_name, group_name, user_name, **kwargs):  # noqa: E501
        """Remove an external user from group in MFT for site.  # noqa: E501

        Remove an external user from group in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_from_mft_user_group_for_site(site_name, group_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group. (required)
        :param str user_name: The user name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_external_user_from_mft_user_group_for_site_with_http_info(site_name, group_name, user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_external_user_from_mft_user_group_for_site_with_http_info(site_name, group_name, user_name, **kwargs)  # noqa: E501
            return data

    def delete_external_user_from_mft_user_group_for_site_with_http_info(self, site_name, group_name, user_name, **kwargs):  # noqa: E501
        """Remove an external user from group in MFT for site.  # noqa: E501

        Remove an external user from group in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_from_mft_user_group_for_site_with_http_info(site_name, group_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group. (required)
        :param str user_name: The user name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'group_name', 'user_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_external_user_from_mft_user_group_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `delete_external_user_from_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'group_name' is set
        if ('group_name' not in params or
                params['group_name'] is None):
            raise ValueError("Missing the required parameter `group_name` when calling `delete_external_user_from_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `delete_external_user_from_mft_user_group_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'group_name' in params:
            path_params['groupName'] = params['group_name']  # noqa: E501
        if 'user_name' in params:
            path_params['userName'] = params['user_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroup/{groupName}/user/{userName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_external_user_or_user_group_from_mft_folder(self, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Remove an external user or user group from an existing virtual folder in MFT.  # noqa: E501

        Remove an external user or user group from an existing virtual folder in MFT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_or_user_group_from_mft_folder(folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_external_user_or_user_group_from_mft_folder_with_http_info(folder_name, user_or_group, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_external_user_or_user_group_from_mft_folder_with_http_info(folder_name, user_or_group, **kwargs)  # noqa: E501
            return data

    def delete_external_user_or_user_group_from_mft_folder_with_http_info(self, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Remove an external user or user group from an existing virtual folder in MFT.  # noqa: E501

        Remove an external user or user group from an existing virtual folder in MFT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_or_user_group_from_mft_folder_with_http_info(folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_name', 'user_or_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_external_user_or_user_group_from_mft_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `delete_external_user_or_user_group_from_mft_folder`")  # noqa: E501
        # verify the required parameter 'user_or_group' is set
        if ('user_or_group' not in params or
                params['user_or_group'] is None):
            raise ValueError("Missing the required parameter `user_or_group` when calling `delete_external_user_or_user_group_from_mft_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501
        if 'user_or_group' in params:
            path_params['userOrGroup'] = params['user_or_group']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/virtualfolder/{folderName}/user/{userOrGroup}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_external_user_or_user_group_from_mft_folder_for_site(self, site_name, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Remove an external user or user group from an existing virtual folder in MFT for site.  # noqa: E501

        Remove an external user or user group from an existing virtual folder in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_or_user_group_from_mft_folder_for_site(site_name, folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_external_user_or_user_group_from_mft_folder_for_site_with_http_info(site_name, folder_name, user_or_group, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_external_user_or_user_group_from_mft_folder_for_site_with_http_info(site_name, folder_name, user_or_group, **kwargs)  # noqa: E501
            return data

    def delete_external_user_or_user_group_from_mft_folder_for_site_with_http_info(self, site_name, folder_name, user_or_group, **kwargs):  # noqa: E501
        """Remove an external user or user group from an existing virtual folder in MFT for site.  # noqa: E501

        Remove an external user or user group from an existing virtual folder in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_external_user_or_user_group_from_mft_folder_for_site_with_http_info(site_name, folder_name, user_or_group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :param str user_or_group: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'folder_name', 'user_or_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_external_user_or_user_group_from_mft_folder_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `delete_external_user_or_user_group_from_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `delete_external_user_or_user_group_from_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'user_or_group' is set
        if ('user_or_group' not in params or
                params['user_or_group'] is None):
            raise ValueError("Missing the required parameter `user_or_group` when calling `delete_external_user_or_user_group_from_mft_folder_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501
        if 'user_or_group' in params:
            path_params['userOrGroup'] = params['user_or_group']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/virtualfolder/{folderName}/user/{userOrGroup}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_host_from_group(self, server, hostgroup, host, **kwargs):  # noqa: E501
        """delete an agent from a hostgroup  # noqa: E501

        Delete an agent from the specified hostgroup. If the group is empty it will also be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_host_from_group(server, hostgroup, host, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the hostgroup belongs to. (required)
        :param str hostgroup: The hostgroup name (required)
        :param str host: The agent to be deleted (required)
        :return: AgentsInGroupSuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_host_from_group_with_http_info(server, hostgroup, host, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_host_from_group_with_http_info(server, hostgroup, host, **kwargs)  # noqa: E501
            return data

    def delete_host_from_group_with_http_info(self, server, hostgroup, host, **kwargs):  # noqa: E501
        """delete an agent from a hostgroup  # noqa: E501

        Delete an agent from the specified hostgroup. If the group is empty it will also be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_host_from_group_with_http_info(server, hostgroup, host, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the hostgroup belongs to. (required)
        :param str hostgroup: The hostgroup name (required)
        :param str host: The agent to be deleted (required)
        :return: AgentsInGroupSuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'hostgroup', 'host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_host_from_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_host_from_group`")  # noqa: E501
        # verify the required parameter 'hostgroup' is set
        if ('hostgroup' not in params or
                params['hostgroup'] is None):
            raise ValueError("Missing the required parameter `hostgroup` when calling `delete_host_from_group`")  # noqa: E501
        # verify the required parameter 'host' is set
        if ('host' not in params or
                params['host'] is None):
            raise ValueError("Missing the required parameter `host` when calling `delete_host_from_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'hostgroup' in params:
            path_params['hostgroup'] = params['hostgroup']  # noqa: E501
        if 'host' in params:
            path_params['host'] = params['host']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/hostgroup/{hostgroup}/agent/{host}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AgentsInGroupSuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_host_group(self, server, hostgroup, **kwargs):  # noqa: E501
        """delete host group  # noqa: E501

        delete host group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_host_group(server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_host_group_with_http_info(server, hostgroup, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_host_group_with_http_info(server, hostgroup, **kwargs)  # noqa: E501
            return data

    def delete_host_group_with_http_info(self, server, hostgroup, **kwargs):  # noqa: E501
        """delete host group  # noqa: E501

        delete host group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_host_group_with_http_info(server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'hostgroup']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_host_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_host_group`")  # noqa: E501
        # verify the required parameter 'hostgroup' is set
        if ('hostgroup' not in params or
                params['hostgroup'] is None):
            raise ValueError("Missing the required parameter `hostgroup` when calling `delete_host_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'hostgroup' in params:
            path_params['hostgroup'] = params['hostgroup']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/hostgroup/{hostgroup}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_host_restrictions(self, ctm, node_prefix, **kwargs):  # noqa: E501
        """Delete Host Restrictions.  # noqa: E501

        Delete Host Restrictions to the agent/s of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_host_restrictions(ctm, node_prefix, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param str node_prefix: The nodePrefix query parameter accepts comma-separated values of node prefixes. It removes all host restrictions matching the submitted nodePrefixes in the API request. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_host_restrictions_with_http_info(ctm, node_prefix, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_host_restrictions_with_http_info(ctm, node_prefix, **kwargs)  # noqa: E501
            return data

    def delete_host_restrictions_with_http_info(self, ctm, node_prefix, **kwargs):  # noqa: E501
        """Delete Host Restrictions.  # noqa: E501

        Delete Host Restrictions to the agent/s of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_host_restrictions_with_http_info(ctm, node_prefix, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param str node_prefix: The nodePrefix query parameter accepts comma-separated values of node prefixes. It removes all host restrictions matching the submitted nodePrefixes in the API request. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ctm', 'node_prefix']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_host_restrictions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `delete_host_restrictions`")  # noqa: E501
        # verify the required parameter 'node_prefix' is set
        if ('node_prefix' not in params or
                params['node_prefix'] is None):
            raise ValueError("Missing the required parameter `node_prefix` when calling `delete_host_restrictions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501

        query_params = []
        if 'node_prefix' in params:
            query_params.append(('nodePrefix', params['node_prefix']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/hostRestriction', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ldap_group_from_mft_user_group_for_site(self, site_name, group_name, ldap_group_name, **kwargs):  # noqa: E501
        """Remove an LDAP group from group in MFT for site.  # noqa: E501

        Remove an LDAP group from group in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ldap_group_from_mft_user_group_for_site(site_name, group_name, ldap_group_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group. (required)
        :param str ldap_group_name: The LDAP group name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ldap_group_from_mft_user_group_for_site_with_http_info(site_name, group_name, ldap_group_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ldap_group_from_mft_user_group_for_site_with_http_info(site_name, group_name, ldap_group_name, **kwargs)  # noqa: E501
            return data

    def delete_ldap_group_from_mft_user_group_for_site_with_http_info(self, site_name, group_name, ldap_group_name, **kwargs):  # noqa: E501
        """Remove an LDAP group from group in MFT for site.  # noqa: E501

        Remove an LDAP group from group in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ldap_group_from_mft_user_group_for_site_with_http_info(site_name, group_name, ldap_group_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str group_name: Name of Group. (required)
        :param str ldap_group_name: The LDAP group name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'group_name', 'ldap_group_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ldap_group_from_mft_user_group_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `delete_ldap_group_from_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'group_name' is set
        if ('group_name' not in params or
                params['group_name'] is None):
            raise ValueError("Missing the required parameter `group_name` when calling `delete_ldap_group_from_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'ldap_group_name' is set
        if ('ldap_group_name' not in params or
                params['ldap_group_name'] is None):
            raise ValueError("Missing the required parameter `ldap_group_name` when calling `delete_ldap_group_from_mft_user_group_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'group_name' in params:
            path_params['groupName'] = params['group_name']  # noqa: E501
        if 'ldap_group_name' in params:
            path_params['ldapGroupName'] = params['ldap_group_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroup/{groupName}/ldapGroup/{ldapGroupName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_mft_folder(self, folder_name, **kwargs):  # noqa: E501
        """Delete a virtual folder.  # noqa: E501

        Delete an existing virtual folder in MFT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_folder(folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_mft_folder_with_http_info(folder_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_mft_folder_with_http_info(folder_name, **kwargs)  # noqa: E501
            return data

    def delete_mft_folder_with_http_info(self, folder_name, **kwargs):  # noqa: E501
        """Delete a virtual folder.  # noqa: E501

        Delete an existing virtual folder in MFT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_folder_with_http_info(folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_mft_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `delete_mft_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/virtualfolder/{folderName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_mft_folder_for_site(self, site_name, folder_name, **kwargs):  # noqa: E501
        """Delete a virtual folder for site.  # noqa: E501

        Delete an existing virtual folder in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_folder_for_site(site_name, folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_mft_folder_for_site_with_http_info(site_name, folder_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_mft_folder_for_site_with_http_info(site_name, folder_name, **kwargs)  # noqa: E501
            return data

    def delete_mft_folder_for_site_with_http_info(self, site_name, folder_name, **kwargs):  # noqa: E501
        """Delete a virtual folder for site.  # noqa: E501

        Delete an existing virtual folder in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_folder_for_site_with_http_info(site_name, folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'folder_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_mft_folder_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `delete_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `delete_mft_folder_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/virtualfolder/{folderName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_mft_processing_rule_for_site(self, site_name, rule_name, **kwargs):  # noqa: E501
        """Delete MFTE processing rule for site.  # noqa: E501

        Delete MFTE processing rule for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_processing_rule_for_site(site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str rule_name: Name of rule (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_mft_processing_rule_for_site_with_http_info(site_name, rule_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_mft_processing_rule_for_site_with_http_info(site_name, rule_name, **kwargs)  # noqa: E501
            return data

    def delete_mft_processing_rule_for_site_with_http_info(self, site_name, rule_name, **kwargs):  # noqa: E501
        """Delete MFTE processing rule for site.  # noqa: E501

        Delete MFTE processing rule for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_processing_rule_for_site_with_http_info(site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str rule_name: Name of rule (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'rule_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_mft_processing_rule_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `delete_mft_processing_rule_for_site`")  # noqa: E501
        # verify the required parameter 'rule_name' is set
        if ('rule_name' not in params or
                params['rule_name'] is None):
            raise ValueError("Missing the required parameter `rule_name` when calling `delete_mft_processing_rule_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'rule_name' in params:
            path_params['ruleName'] = params['rule_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/processingRule/{ruleName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_mft_user_group(self, name, **kwargs):  # noqa: E501
        """Delete user group.  # noqa: E501

        Delete user group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_user_group(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_mft_user_group_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_mft_user_group_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_mft_user_group_with_http_info(self, name, **kwargs):  # noqa: E501
        """Delete user group.  # noqa: E501

        Delete user group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_user_group_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_mft_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_mft_user_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/usergroup/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_mft_user_group_for_site(self, site_name, name, **kwargs):  # noqa: E501
        """Delete user group for site.  # noqa: E501

        Delete user group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_user_group_for_site(site_name, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_mft_user_group_for_site_with_http_info(site_name, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_mft_user_group_for_site_with_http_info(site_name, name, **kwargs)  # noqa: E501
            return data

    def delete_mft_user_group_for_site_with_http_info(self, site_name, name, **kwargs):  # noqa: E501
        """Delete user group for site.  # noqa: E501

        Delete user group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_mft_user_group_for_site_with_http_info(site_name, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_mft_user_group_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `delete_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_mft_user_group_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroup/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pgp_template(self, server, agent, template_name, **kwargs):  # noqa: E501
        """Delete PGP Template  # noqa: E501

        Delete PGP Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pgp_template(server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The PGP Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pgp_template_with_http_info(server, agent, template_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pgp_template_with_http_info(server, agent, template_name, **kwargs)  # noqa: E501
            return data

    def delete_pgp_template_with_http_info(self, server, agent, template_name, **kwargs):  # noqa: E501
        """Delete PGP Template  # noqa: E501

        Delete PGP Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pgp_template_with_http_info(server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The PGP Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'template_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pgp_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_pgp_template`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `delete_pgp_template`")  # noqa: E501
        # verify the required parameter 'template_name' is set
        if ('template_name' not in params or
                params['template_name'] is None):
            raise ValueError("Missing the required parameter `template_name` when calling `delete_pgp_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'template_name' in params:
            path_params['templateName'] = params['template_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/pgptemplate/{templateName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_remote_host(self, server, remotehost, **kwargs):  # noqa: E501
        """delete a remote host from Server  # noqa: E501

        Delete a remote host from a Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_remote_host(server, remotehost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host is connected to. (required)
        :param str remotehost: The name of the remote host to delete. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_remote_host_with_http_info(server, remotehost, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_remote_host_with_http_info(server, remotehost, **kwargs)  # noqa: E501
            return data

    def delete_remote_host_with_http_info(self, server, remotehost, **kwargs):  # noqa: E501
        """delete a remote host from Server  # noqa: E501

        Delete a remote host from a Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_remote_host_with_http_info(server, remotehost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host is connected to. (required)
        :param str remotehost: The name of the remote host to delete. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'remotehost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_remote_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_remote_host`")  # noqa: E501
        # verify the required parameter 'remotehost' is set
        if ('remotehost' not in params or
                params['remotehost'] is None):
            raise ValueError("Missing the required parameter `remotehost` when calling `delete_remote_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'remotehost' in params:
            path_params['remotehost'] = params['remotehost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/remotehost/{remotehost}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_role_from_ldap_group(self, ldapgroup, role, **kwargs):  # noqa: E501
        """Delete a role from LDAP group  # noqa: E501

        Delete a role from LDAP group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_role_from_ldap_group(ldapgroup, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ldapgroup: Name of LDAP group (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_role_from_ldap_group_with_http_info(ldapgroup, role, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_role_from_ldap_group_with_http_info(ldapgroup, role, **kwargs)  # noqa: E501
            return data

    def delete_role_from_ldap_group_with_http_info(self, ldapgroup, role, **kwargs):  # noqa: E501
        """Delete a role from LDAP group  # noqa: E501

        Delete a role from LDAP group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_role_from_ldap_group_with_http_info(ldapgroup, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ldapgroup: Name of LDAP group (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ldapgroup', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_role_from_ldap_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ldapgroup' is set
        if ('ldapgroup' not in params or
                params['ldapgroup'] is None):
            raise ValueError("Missing the required parameter `ldapgroup` when calling `delete_role_from_ldap_group`")  # noqa: E501
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `delete_role_from_ldap_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ldapgroup' in params:
            path_params['ldapgroup'] = params['ldapgroup']  # noqa: E501
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/ldap/{ldapgroup}/role/{role}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_run_as_user(self, server, agent, user, **kwargs):  # noqa: E501
        """delete Run-as user  # noqa: E501

        Delete Run-as user from server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_run_as_user(server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_run_as_user_with_http_info(server, agent, user, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_run_as_user_with_http_info(server, agent, user, **kwargs)  # noqa: E501
            return data

    def delete_run_as_user_with_http_info(self, server, agent, user, **kwargs):  # noqa: E501
        """delete Run-as user  # noqa: E501

        Delete Run-as user from server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_run_as_user_with_http_info(server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_run_as_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_run_as_user`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `delete_run_as_user`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `delete_run_as_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/runasuser/{agent}/{user}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_secret(self, name, **kwargs):  # noqa: E501
        """Delete an existing secret  # noqa: E501

        Delete an existing secret from the secrets vault.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_secret(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of the secret to update (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_secret_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_secret_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_secret_with_http_info(self, name, **kwargs):  # noqa: E501
        """Delete an existing secret  # noqa: E501

        Delete an existing secret from the secrets vault.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_secret_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of the secret to update (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_secret`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/secret/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ssh_key(self, ctm, key_name, pass_phrase, **kwargs):  # noqa: E501
        """delete an SSH key from the control-m server.  # noqa: E501

        delete an SSH key from the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ssh_key(ctm, key_name, pass_phrase, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param str key_name: The name for the key . REQUIRED. (required)
        :param str pass_phrase: The password for the key file . REQUIRED. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ssh_key_with_http_info(ctm, key_name, pass_phrase, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ssh_key_with_http_info(ctm, key_name, pass_phrase, **kwargs)  # noqa: E501
            return data

    def delete_ssh_key_with_http_info(self, ctm, key_name, pass_phrase, **kwargs):  # noqa: E501
        """delete an SSH key from the control-m server.  # noqa: E501

        delete an SSH key from the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ssh_key_with_http_info(ctm, key_name, pass_phrase, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param str key_name: The name for the key . REQUIRED. (required)
        :param str pass_phrase: The password for the key file . REQUIRED. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ctm', 'key_name', 'pass_phrase']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ssh_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `delete_ssh_key`")  # noqa: E501
        # verify the required parameter 'key_name' is set
        if ('key_name' not in params or
                params['key_name'] is None):
            raise ValueError("Missing the required parameter `key_name` when calling `delete_ssh_key`")  # noqa: E501
        # verify the required parameter 'pass_phrase' is set
        if ('pass_phrase' not in params or
                params['pass_phrase'] is None):
            raise ValueError("Missing the required parameter `pass_phrase` when calling `delete_ssh_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501
        if 'key_name' in params:
            path_params['keyName'] = params['key_name']  # noqa: E501
        if 'pass_phrase' in params:
            path_params['passPhrase'] = params['pass_phrase']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/sshkey/{keyName}/{passPhrase}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user(self, user, **kwargs):  # noqa: E501
        """Delete user  # noqa: E501

        Delete user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_user_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def delete_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Delete user  # noqa: E501

        Delete user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `delete_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/{user}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_zos_template(self, server, agent, template_name, **kwargs):  # noqa: E501
        """Delete z/OS Template  # noqa: E501

        Delete z/OS Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_zos_template(server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The z/OS Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_zos_template_with_http_info(server, agent, template_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_zos_template_with_http_info(server, agent, template_name, **kwargs)  # noqa: E501
            return data

    def delete_zos_template_with_http_info(self, server, agent, template_name, **kwargs):  # noqa: E501
        """Delete z/OS Template  # noqa: E501

        Delete z/OS Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_zos_template_with_http_info(server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The z/OS Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'template_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_zos_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `delete_zos_template`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `delete_zos_template`")  # noqa: E501
        # verify the required parameter 'template_name' is set
        if ('template_name' not in params or
                params['template_name'] is None):
            raise ValueError("Missing the required parameter `template_name` when calling `delete_zos_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'template_name' in params:
            path_params['templateName'] = params['template_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/zostemplate/{templateName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deploy_agent_certificate(self, crt_file, ca_chain_file, server, agent, **kwargs):  # noqa: E501
        """Deploy certificate (CRT).  # noqa: E501

        Deploy certificate (CRT) on SSL configured Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_agent_certificate(crt_file, ca_chain_file, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crt_file: (required)
        :param str ca_chain_file: (required)
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.deploy_agent_certificate_with_http_info(crt_file, ca_chain_file, server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.deploy_agent_certificate_with_http_info(crt_file, ca_chain_file, server, agent, **kwargs)  # noqa: E501
            return data

    def deploy_agent_certificate_with_http_info(self, crt_file, ca_chain_file, server, agent, **kwargs):  # noqa: E501
        """Deploy certificate (CRT).  # noqa: E501

        Deploy certificate (CRT) on SSL configured Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_agent_certificate_with_http_info(crt_file, ca_chain_file, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crt_file: (required)
        :param str ca_chain_file: (required)
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crt_file', 'ca_chain_file', 'server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deploy_agent_certificate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crt_file' is set
        if ('crt_file' not in params or
                params['crt_file'] is None):
            raise ValueError("Missing the required parameter `crt_file` when calling `deploy_agent_certificate`")  # noqa: E501
        # verify the required parameter 'ca_chain_file' is set
        if ('ca_chain_file' not in params or
                params['ca_chain_file'] is None):
            raise ValueError("Missing the required parameter `ca_chain_file` when calling `deploy_agent_certificate`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `deploy_agent_certificate`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `deploy_agent_certificate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'crt_file' in params:
            local_var_files['crtFile'] = params['crt_file']  # noqa: E501
        if 'ca_chain_file' in params:
            local_var_files['caChainFile'] = params['ca_chain_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/crt', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_agent(self, server, agent, **kwargs):  # noqa: E501
        """disable agent from the Server  # noqa: E501

        Disable an Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_agent(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected too. (required)
        :param str agent: The Agent to be disabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def disable_agent_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """disable agent from the Server  # noqa: E501

        Disable an Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_agent_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected too. (required)
        :param str agent: The Agent to be disabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `disable_agent`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `disable_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_agentless_host(self, server, agentlesshost, **kwargs):  # noqa: E501
        """disable agentless host from the Server  # noqa: E501

        disable an Agentless Host. This command does not install or configure the Agentless Host. It only disable existing Agentless Host in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_agentless_host(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected too. (required)
        :param str agentlesshost: The Agentless Host to be disabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def disable_agentless_host_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """disable agentless host from the Server  # noqa: E501

        disable an Agentless Host. This command does not install or configure the Agentless Host. It only disable existing Agentless Host in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_agentless_host_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected too. (required)
        :param str agentlesshost: The Agentless Host to be disabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_agentless_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `disable_agentless_host`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `disable_agentless_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_ctm_server(self, server, **kwargs):  # noqa: E501
        """Set server to disabled state.  # noqa: E501

        Set server to disabled state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_ctm_server(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_ctm_server_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_ctm_server_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def disable_ctm_server_with_http_info(self, server, **kwargs):  # noqa: E501
        """Set server to disabled state.  # noqa: E501

        Set server to disabled state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_ctm_server_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_ctm_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `disable_ctm_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_mft_processing_rule_for_site(self, site_name, rule_name, **kwargs):  # noqa: E501
        """Disable MFTE processing rule for site  # noqa: E501

        Disable MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_mft_processing_rule_for_site(site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str rule_name: Name of rule (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_mft_processing_rule_for_site_with_http_info(site_name, rule_name, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_mft_processing_rule_for_site_with_http_info(site_name, rule_name, **kwargs)  # noqa: E501
            return data

    def disable_mft_processing_rule_for_site_with_http_info(self, site_name, rule_name, **kwargs):  # noqa: E501
        """Disable MFTE processing rule for site  # noqa: E501

        Disable MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_mft_processing_rule_for_site_with_http_info(site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str rule_name: Name of rule (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'rule_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_mft_processing_rule_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `disable_mft_processing_rule_for_site`")  # noqa: E501
        # verify the required parameter 'rule_name' is set
        if ('rule_name' not in params or
                params['rule_name'] is None):
            raise ValueError("Missing the required parameter `rule_name` when calling `disable_mft_processing_rule_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'rule_name' in params:
            path_params['ruleName'] = params['rule_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/processingRule/{ruleName}/disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_agent(self, server, agent, **kwargs):  # noqa: E501
        """enable agent from the Server  # noqa: E501

        Enable an Agent. This command does not install or configure the agent. It only enable existing agent in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_agent(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected too. (required)
        :param str agent: The Agent to be enabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def enable_agent_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """enable agent from the Server  # noqa: E501

        Enable an Agent. This command does not install or configure the agent. It only enable existing agent in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_agent_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected too. (required)
        :param str agent: The Agent to be enabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `enable_agent`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `enable_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_agentless_host(self, server, agentlesshost, **kwargs):  # noqa: E501
        """enable agentless host from the Server  # noqa: E501

        Enable an Agentless Host. This command does not install or configure the Agentless Host. It only enable existing Agentless Host in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_agentless_host(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected too. (required)
        :param str agentlesshost: The Agentless Host to be enabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def enable_agentless_host_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """enable agentless host from the Server  # noqa: E501

        Enable an Agentless Host. This command does not install or configure the Agentless Host. It only enable existing Agentless Host in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_agentless_host_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host is connected too. (required)
        :param str agentlesshost: The Agentless Host to be enabled. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_agentless_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `enable_agentless_host`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `enable_agentless_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_ctm_server(self, server, **kwargs):  # noqa: E501
        """Set server to enabled state.  # noqa: E501

        Set server to enabled state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_ctm_server(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_ctm_server_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_ctm_server_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def enable_ctm_server_with_http_info(self, server, **kwargs):  # noqa: E501
        """Set server to enabled state.  # noqa: E501

        Set server to enabled state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_ctm_server_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_ctm_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `enable_ctm_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_mft_processing_rule_for_site(self, site_name, rule_name, **kwargs):  # noqa: E501
        """Enable MFTE processing rule for site  # noqa: E501

        Enable MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_mft_processing_rule_for_site(site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str rule_name: Name of rule (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_mft_processing_rule_for_site_with_http_info(site_name, rule_name, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_mft_processing_rule_for_site_with_http_info(site_name, rule_name, **kwargs)  # noqa: E501
            return data

    def enable_mft_processing_rule_for_site_with_http_info(self, site_name, rule_name, **kwargs):  # noqa: E501
        """Enable MFTE processing rule for site  # noqa: E501

        Enable MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_mft_processing_rule_for_site_with_http_info(site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str rule_name: Name of rule (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'rule_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_mft_processing_rule_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `enable_mft_processing_rule_for_site`")  # noqa: E501
        # verify the required parameter 'rule_name' is set
        if ('rule_name' not in params or
                params['rule_name'] is None):
            raise ValueError("Missing the required parameter `rule_name` when calling `enable_mft_processing_rule_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'rule_name' in params:
            path_params['ruleName'] = params['rule_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/processingRule/{ruleName}/enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def failover(self, server, **kwargs):  # noqa: E501
        """Perform Control-M/Server failover to the secondary Control-M/Server server.  # noqa: E501

        Perform Control-M/Server failover to the secondary Control-M/Server server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.failover(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param bool _async: Whether the call performs asynchronously, either true or false. The default is false (call performs synchronously).
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.failover_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.failover_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def failover_with_http_info(self, server, **kwargs):  # noqa: E501
        """Perform Control-M/Server failover to the secondary Control-M/Server server.  # noqa: E501

        Perform Control-M/Server failover to the secondary Control-M/Server server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.failover_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param bool _async: Whether the call performs asynchronously, either true or false. The default is false (call performs synchronously).
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', '_async']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method failover" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `failover`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []
        if '_async' in params:
            query_params.append(('async', params['_async']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/failover', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fallback(self, server, **kwargs):  # noqa: E501
        """Perform Control-M/Server fallback to the primary Control-M/Server server.  # noqa: E501

        Perform Control-M/Server fallback to the primary Control-M/Server server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fallback(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fallback_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.fallback_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def fallback_with_http_info(self, server, **kwargs):  # noqa: E501
        """Perform Control-M/Server fallback to the primary Control-M/Server server.  # noqa: E501

        Perform Control-M/Server fallback to the primary Control-M/Server server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fallback_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fallback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `fallback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/fallback', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_mft_rsa_ssh_key(self, body, server, agent, **kwargs):  # noqa: E501
        """Generate RSA SSH Key  # noqa: E501

        Generate RSA SSH Key pair for SFTP account authentication  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_mft_rsa_ssh_key(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SshKeyProperties body: Ssh Key pair properites (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_mft_rsa_ssh_key_with_http_info(body, server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_mft_rsa_ssh_key_with_http_info(body, server, agent, **kwargs)  # noqa: E501
            return data

    def generate_mft_rsa_ssh_key_with_http_info(self, body, server, agent, **kwargs):  # noqa: E501
        """Generate RSA SSH Key  # noqa: E501

        Generate RSA SSH Key pair for SFTP account authentication  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_mft_rsa_ssh_key_with_http_info(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SshKeyProperties body: Ssh Key pair properites (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_mft_rsa_ssh_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `generate_mft_rsa_ssh_key`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `generate_mft_rsa_ssh_key`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `generate_mft_rsa_ssh_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/ssh/key', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agent_certificate_expiration_date(self, server, agent, **kwargs):  # noqa: E501
        """Get certificate expiration date.  # noqa: E501

        Get the certificate expiration date of SSL configured Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agent_certificate_expiration_date(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :return: AgentCertificateExpirationData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_agent_certificate_expiration_date_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agent_certificate_expiration_date_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_agent_certificate_expiration_date_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """Get certificate expiration date.  # noqa: E501

        Get the certificate expiration date of SSL configured Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agent_certificate_expiration_date_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :return: AgentCertificateExpirationData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent_certificate_expiration_date" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_agent_certificate_expiration_date`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_agent_certificate_expiration_date`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/crt/expiration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AgentCertificateExpirationData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agent_parameters(self, server, agent, **kwargs):  # noqa: E501
        """get agent parameters  # noqa: E501

        Get all the parameters of the specified Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agent_parameters(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to query. (required)
        :param bool extended_data: True to return more agent parameters. HIDDEN
        :return: KeyValueListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_agent_parameters_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agent_parameters_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_agent_parameters_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """get agent parameters  # noqa: E501

        Get all the parameters of the specified Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agent_parameters_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to query. (required)
        :param bool extended_data: True to return more agent parameters. HIDDEN
        :return: KeyValueListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'extended_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent_parameters" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_agent_parameters`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_agent_parameters`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []
        if 'extended_data' in params:
            query_params.append(('extendedData', params['extended_data']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/params', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KeyValueListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agentless_host_properties(self, server, agentlesshost, **kwargs):  # noqa: E501
        """get an agentless host configuration from Server  # noqa: E501

        Get the agentless host configuration properties from the Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agentless_host_properties(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host  is connected to. (required)
        :param str agentlesshost: The name of the agentless host. (required)
        :return: AddRemoteHostParams
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_agentless_host_properties_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agentless_host_properties_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def get_agentless_host_properties_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """get an agentless host configuration from Server  # noqa: E501

        Get the agentless host configuration properties from the Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agentless_host_properties_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agentless host  is connected to. (required)
        :param str agentlesshost: The name of the agentless host. (required)
        :return: AddRemoteHostParams
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agentless_host_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_agentless_host_properties`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `get_agentless_host_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AddRemoteHostParams',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agentless_hosts(self, server, **kwargs):  # noqa: E501
        """get Server agentless hosts  # noqa: E501

        Get all the agentless hosts of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agentless_hosts(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to query. (required)
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_agentless_hosts_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agentless_hosts_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_agentless_hosts_with_http_info(self, server, **kwargs):  # noqa: E501
        """get Server agentless hosts  # noqa: E501

        Get all the agentless hosts of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agentless_hosts_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to query. (required)
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agentless_hosts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_agentless_hosts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshosts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agents(self, server, **kwargs):  # noqa: E501
        """get Server agents  # noqa: E501

        Get all the agents of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agents(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to query. Optionally you can filter agent name of host or alias of the Agent (required)
        :param str agent: Optionally case insensitive agent name filter of host or alias of the Agent. `ctm server:agents::get Server AgentName` returns all agents which names start with `agentname`
        :return: AgentDetailsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_agents_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agents_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_agents_with_http_info(self, server, **kwargs):  # noqa: E501
        """get Server agents  # noqa: E501

        Get all the agents of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_agents_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to query. Optionally you can filter agent name of host or alias of the Agent (required)
        :param str agent: Optionally case insensitive agent name filter of host or alias of the Agent. `ctm server:agents::get Server AgentName` returns all agents which names start with `agentname`
        :return: AgentDetailsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_agents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []
        if 'agent' in params:
            query_params.append(('agent', params['agent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AgentDetailsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_archive_rules(self, **kwargs):  # noqa: E501
        """Get all Workload Archiving rules  # noqa: E501

        Get all the Archiving rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_archive_rules(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ArchiveRulesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_archive_rules_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_archive_rules_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_archive_rules_with_http_info(self, **kwargs):  # noqa: E501
        """Get all Workload Archiving rules  # noqa: E501

        Get all the Archiving rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_archive_rules_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ArchiveRulesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_archive_rules" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/archive/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArchiveRulesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_authorization_roles(self, **kwargs):  # noqa: E501
        """Get Authorization Roles  # noqa: E501

        Get Authorization Roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_authorization_roles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: The Role name.
        :param str description: The Role description.
        :return: RoleHeaderList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_authorization_roles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_authorization_roles_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_authorization_roles_with_http_info(self, **kwargs):  # noqa: E501
        """Get Authorization Roles  # noqa: E501

        Get Authorization Roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_authorization_roles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: The Role name.
        :param str description: The Role description.
        :return: RoleHeaderList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['role', 'description']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_authorization_roles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'role' in params:
            query_params.append(('role', params['role']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoleHeaderList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_organization_groups(self, **kwargs):  # noqa: E501
        """Get All organization groups  # noqa: E501

        Get All organization groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_organization_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organizationgroup: The organization group name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_organization_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_organization_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_organization_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Get All organization groups  # noqa: E501

        Get All organization groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_organization_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organizationgroup: The organization group name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organizationgroup']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_organization_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organizationgroup' in params:
            query_params.append(('organizationgroup', params['organizationgroup']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/organizationgroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_organization_users(self, **kwargs):  # noqa: E501
        """Get All organization users  # noqa: E501

        Get All organization users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_organization_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organization_user: The user name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_organization_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_organization_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_organization_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get All organization users  # noqa: E501

        Get All organization users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_organization_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organization_user: The user name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_organization_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_user' in params:
            query_params.append(('organizationUser', params['organization_user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/organizationusers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_roles_associated_with_organization_group(self, organizationgroup, **kwargs):  # noqa: E501
        """Get Authorization Roles associated with an organization group  # noqa: E501

        Get Authorization Roles associated with an organization group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles_associated_with_organization_group(organizationgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organizationgroup: Name of organization group (required)
        :param str role: The Role name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_roles_associated_with_organization_group_with_http_info(organizationgroup, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_roles_associated_with_organization_group_with_http_info(organizationgroup, **kwargs)  # noqa: E501
            return data

    def get_all_roles_associated_with_organization_group_with_http_info(self, organizationgroup, **kwargs):  # noqa: E501
        """Get Authorization Roles associated with an organization group  # noqa: E501

        Get Authorization Roles associated with an organization group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles_associated_with_organization_group_with_http_info(organizationgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str organizationgroup: Name of organization group (required)
        :param str role: The Role name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organizationgroup', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_roles_associated_with_organization_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organizationgroup' is set
        if ('organizationgroup' not in params or
                params['organizationgroup'] is None):
            raise ValueError("Missing the required parameter `organizationgroup` when calling `get_all_roles_associated_with_organization_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organizationgroup' in params:
            path_params['organizationgroup'] = params['organizationgroup']  # noqa: E501

        query_params = []
        if 'role' in params:
            query_params.append(('role', params['role']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/organizationgroup/{organizationgroup}/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_roles_associated_with_organization_user(self, user, **kwargs):  # noqa: E501
        """Get Authorization Roles associated with an Organization user  # noqa: E501

        Get Authorization Roles associated with an Organization user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles_associated_with_organization_user(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Name of organization user (required)
        :param str role: The Role name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_roles_associated_with_organization_user_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_roles_associated_with_organization_user_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_all_roles_associated_with_organization_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Get Authorization Roles associated with an Organization user  # noqa: E501

        Get Authorization Roles associated with an Organization user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles_associated_with_organization_user_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Name of organization user (required)
        :param str role: The Role name.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_roles_associated_with_organization_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_all_roles_associated_with_organization_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'role' in params:
            query_params.append(('role', params['role']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/organizationuser/{user}/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_users(self, **kwargs):  # noqa: E501
        """Get users  # noqa: E501

        Get users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The user name.
        :param str full_name: The user full name.
        :param str description: The user description.
        :return: list[UserHeader]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get users  # noqa: E501

        Get users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The user name.
        :param str full_name: The user full name.
        :param str description: The user description.
        :return: list[UserHeader]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'full_name', 'description']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'full_name' in params:
            query_params.append(('fullName', params['full_name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserHeader]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_archive_statistics(self, **kwargs):  # noqa: E501
        """Get Workload Archiving statistics  # noqa: E501

        Get list of statistical information for each Archiving rule and total information about the number of jobs that have been archived, data size of all job logs and outputs that have been archived, size of the Workload Archiving database including all tables and indexes and percentage of disk space used on the Workload Archiving server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_archive_statistics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RulesStatisticListSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_archive_statistics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_archive_statistics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_archive_statistics_with_http_info(self, **kwargs):  # noqa: E501
        """Get Workload Archiving statistics  # noqa: E501

        Get list of statistical information for each Archiving rule and total information about the number of jobs that have been archived, data size of all job logs and outputs that have been archived, size of the Workload Archiving database including all tables and indexes and percentage of disk space used on the Workload Archiving server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_archive_statistics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RulesStatisticListSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_archive_statistics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/archive/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RulesStatisticListSummary',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_communication_analysis_report_for_agent(self, server, agent, **kwargs):  # noqa: E501
        """analyze communication between an Agent and its Server  # noqa: E501

        Analyze communication between specific Control-M Server and Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_communication_analysis_report_for_agent(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to which the Agent is connected. (required)
        :param str agent: The Agent to analyze communication with. (required)
        :return: CommunicationAnalysisResponseType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_communication_analysis_report_for_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_communication_analysis_report_for_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_communication_analysis_report_for_agent_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """analyze communication between an Agent and its Server  # noqa: E501

        Analyze communication between specific Control-M Server and Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_communication_analysis_report_for_agent_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to which the Agent is connected. (required)
        :param str agent: The Agent to analyze communication with. (required)
        :return: CommunicationAnalysisResponseType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_communication_analysis_report_for_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_communication_analysis_report_for_agent`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_communication_analysis_report_for_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/analysis', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationAnalysisResponseType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ctm_gate_ways(self, name, **kwargs):  # noqa: E501
        """Get details of specific gateway component in the system.  # noqa: E501

        Get details of specific gateway component in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ctm_gate_ways(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Server logical name (required)
        :param str host: Server host.
        :return: GatewayList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ctm_gate_ways_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ctm_gate_ways_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_ctm_gate_ways_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get details of specific gateway component in the system.  # noqa: E501

        Get details of specific gateway component in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ctm_gate_ways_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Server logical name (required)
        :param str host: Server host.
        :return: GatewayList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ctm_gate_ways" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_ctm_gate_ways`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'host' in params:
            query_params.append(('host', params['host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{name}/gateways', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GatewayList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ctm_high_availability_status(self, server, **kwargs):  # noqa: E501
        """Get Control-M/Server High Availability status  # noqa: E501

        Get Control-M/Server High Availability status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ctm_high_availability_status(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: HighAvailabilityStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ctm_high_availability_status_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ctm_high_availability_status_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_ctm_high_availability_status_with_http_info(self, server, **kwargs):  # noqa: E501
        """Get Control-M/Server High Availability status  # noqa: E501

        Get Control-M/Server High Availability status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ctm_high_availability_status_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: HighAvailabilityStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ctm_high_availability_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_ctm_high_availability_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/highavailabilitystatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HighAvailabilityStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_em_high_availability_status(self, **kwargs):  # noqa: E501
        """Get EM High Availability status  # noqa: E501

        Get EM High Availability status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_em_high_availability_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HighAvailabilityStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_em_high_availability_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_em_high_availability_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_em_high_availability_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get EM High Availability status  # noqa: E501

        Get EM High Availability status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_em_high_availability_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: HighAvailabilityStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_em_high_availability_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/em/highavailabilitystatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HighAvailabilityStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_user_authorized_folders(self, name, **kwargs):  # noqa: E501
        """Get MFT external user authorized folders  # noqa: E501

        Get MFT external user authorized folders  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_user_authorized_folders(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The external user name. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_external_user_authorized_folders_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_external_user_authorized_folders_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_external_user_authorized_folders_with_http_info(self, name, **kwargs):  # noqa: E501
        """Get MFT external user authorized folders  # noqa: E501

        Get MFT external user authorized folders  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_user_authorized_folders_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The external user name. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_user_authorized_folders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_external_user_authorized_folders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externaluser/{name}/virtualfolders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_user_authorized_folders_for_site(self, site_name, name, **kwargs):  # noqa: E501
        """Get MFT external user authorized folders for site  # noqa: E501

        Get MFT external user authorized folders for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_user_authorized_folders_for_site(site_name, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: The external user name. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_external_user_authorized_folders_for_site_with_http_info(site_name, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_external_user_authorized_folders_for_site_with_http_info(site_name, name, **kwargs)  # noqa: E501
            return data

    def get_external_user_authorized_folders_for_site_with_http_info(self, site_name, name, **kwargs):  # noqa: E501
        """Get MFT external user authorized folders for site  # noqa: E501

        Get MFT external user authorized folders for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_user_authorized_folders_for_site_with_http_info(site_name, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: The external user name. (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_user_authorized_folders_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_external_user_authorized_folders_for_site`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_external_user_authorized_folders_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externaluser/{name}/virtualfolders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_users(self, **kwargs):  # noqa: E501
        """Get MFT external users that match the search criteria.  # noqa: E501

        Get MFT external users that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The user name.
        :param str email: The user email.
        :param str description: The user description.
        :param str company: The user company.
        :param str phone_number: The user phoneNumber.
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_external_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_external_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_external_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get MFT external users that match the search criteria.  # noqa: E501

        Get MFT external users that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The user name.
        :param str email: The user email.
        :param str description: The user description.
        :param str company: The user company.
        :param str phone_number: The user phoneNumber.
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'email', 'description', 'company', 'phone_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'company' in params:
            query_params.append(('company', params['company']))  # noqa: E501
        if 'phone_number' in params:
            query_params.append(('phoneNumber', params['phone_number']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externalusers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExternalUserData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_users_for_site(self, site_name, **kwargs):  # noqa: E501
        """Get MFT external users for site that match the search criteria.  # noqa: E501

        Get MFT external users for site that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_users_for_site(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str name: The user name.
        :param str email: The user email.
        :param str description: The user description.
        :param str company: The user company.
        :param str phone_number: The user phoneNumber.
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_external_users_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_external_users_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
            return data

    def get_external_users_for_site_with_http_info(self, site_name, **kwargs):  # noqa: E501
        """Get MFT external users for site that match the search criteria.  # noqa: E501

        Get MFT external users for site that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_users_for_site_with_http_info(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str name: The user name.
        :param str email: The user email.
        :param str description: The user description.
        :param str company: The user company.
        :param str phone_number: The user phoneNumber.
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'name', 'email', 'description', 'company', 'phone_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_users_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_external_users_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'company' in params:
            query_params.append(('company', params['company']))  # noqa: E501
        if 'phone_number' in params:
            query_params.append(('phoneNumber', params['phone_number']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externalusers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExternalUserData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fts_settings(self, server, agent, **kwargs):  # noqa: E501
        """Get File Transfer Server (FTS) configuration data.  # noqa: E501

        Get File Transfer Server (FTS) configuration data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fts_settings(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: FtsSettingsData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_fts_settings_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_fts_settings_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_fts_settings_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """Get File Transfer Server (FTS) configuration data.  # noqa: E501

        Get File Transfer Server (FTS) configuration data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fts_settings_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: FtsSettingsData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fts_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_fts_settings`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_fts_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/fts/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FtsSettingsData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_host_restriction_list(self, ctm, **kwargs):  # noqa: E501
        """Get all host restrictions.  # noqa: E501

        Get all host restrictions of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_host_restriction_list(ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :return: list[HostRestriction]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_host_restriction_list_with_http_info(ctm, **kwargs)  # noqa: E501
        else:
            (data) = self.get_host_restriction_list_with_http_info(ctm, **kwargs)  # noqa: E501
            return data

    def get_host_restriction_list_with_http_info(self, ctm, **kwargs):  # noqa: E501
        """Get all host restrictions.  # noqa: E501

        Get all host restrictions of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_host_restriction_list_with_http_info(ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :return: list[HostRestriction]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ctm']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_host_restriction_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `get_host_restriction_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/hostRestrictions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HostRestriction]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hostgroups(self, server, **kwargs):  # noqa: E501
        """get Server hostgroups  # noqa: E501

        Get all the hostgroups of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hostgroups(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the hostgroups belong to. (required)
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hostgroups_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_hostgroups_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_hostgroups_with_http_info(self, server, **kwargs):  # noqa: E501
        """get Server hostgroups  # noqa: E501

        Get all the hostgroups of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hostgroups_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the hostgroups belong to. (required)
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hostgroups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_hostgroups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/hostgroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hostgroups_and_agents_with_tag(self, server, **kwargs):  # noqa: E501
        """get Server host groups with their agents  # noqa: E501

        Get all the host groups with their agents of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hostgroups_and_agents_with_tag(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the host groups belong to. (required)
        :return: HostGroupsDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hostgroups_and_agents_with_tag_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_hostgroups_and_agents_with_tag_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_hostgroups_and_agents_with_tag_with_http_info(self, server, **kwargs):  # noqa: E501
        """get Server host groups with their agents  # noqa: E501

        Get all the host groups with their agents of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hostgroups_and_agents_with_tag_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the host groups belong to. (required)
        :return: HostGroupsDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hostgroups_and_agents_with_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_hostgroups_and_agents_with_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/hostgroups/agents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HostGroupsDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hosts_in_group(self, server, hostgroup, **kwargs):  # noqa: E501
        """get hostgroup agents  # noqa: E501

        Get the agents that compose the specified hostgroup  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hosts_in_group(server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the hostgroup belongs to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: AgentsInGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hosts_in_group_with_http_info(server, hostgroup, **kwargs)  # noqa: E501
        else:
            (data) = self.get_hosts_in_group_with_http_info(server, hostgroup, **kwargs)  # noqa: E501
            return data

    def get_hosts_in_group_with_http_info(self, server, hostgroup, **kwargs):  # noqa: E501
        """get hostgroup agents  # noqa: E501

        Get the agents that compose the specified hostgroup  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hosts_in_group_with_http_info(server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the hostgroup belongs to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: AgentsInGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'hostgroup']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hosts_in_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_hosts_in_group`")  # noqa: E501
        # verify the required parameter 'hostgroup' is set
        if ('hostgroup' not in params or
                params['hostgroup'] is None):
            raise ValueError("Missing the required parameter `hostgroup` when calling `get_hosts_in_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'hostgroup' in params:
            path_params['hostgroup'] = params['hostgroup']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/hostgroup/{hostgroup}/agents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AgentsInGroupListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hub_status_details(self, node_id, **kwargs):  # noqa: E501
        """Get hub status.  # noqa: E501

        Get hub status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hub_status_details(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: Node ID of the hub (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hub_status_details_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_hub_status_details_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_hub_status_details_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Get hub status.  # noqa: E501

        Get hub status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hub_status_details_with_http_info(node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str node_id: Node ID of the hub (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hub_status_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_hub_status_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['nodeId'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/hub/{nodeId}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hub_status_details_for_site(self, site_name, node_id, **kwargs):  # noqa: E501
        """Get hub status in site.  # noqa: E501

        Get hub status in site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hub_status_details_for_site(site_name, node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str node_id: Node ID of the hub (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hub_status_details_for_site_with_http_info(site_name, node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_hub_status_details_for_site_with_http_info(site_name, node_id, **kwargs)  # noqa: E501
            return data

    def get_hub_status_details_for_site_with_http_info(self, site_name, node_id, **kwargs):  # noqa: E501
        """Get hub status in site.  # noqa: E501

        Get hub status in site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hub_status_details_for_site_with_http_info(site_name, node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str node_id: Node ID of the hub (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hub_status_details_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_hub_status_details_for_site`")  # noqa: E501
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_hub_status_details_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'node_id' in params:
            path_params['nodeId'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/hub/{nodeId}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_identity_provider_metadata(self, **kwargs):  # noqa: E501
        """Get identity Provider Metadata file  # noqa: E501

        Get identity Provider Metadata file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_identity_provider_metadata(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_identity_provider_metadata_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_identity_provider_metadata_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_identity_provider_metadata_with_http_info(self, **kwargs):  # noqa: E501
        """Get identity Provider Metadata file  # noqa: E501

        Get identity Provider Metadata file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_identity_provider_metadata_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_identity_provider_metadata" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/systemsettings/saml2identityprovidermetadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_properties(self, server, load_balancer, **kwargs):  # noqa: E501
        """Get loadBalancer parameters  # noqa: E501

        Get loadBalancer parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_properties(server, load_balancer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the loadBalancer is added to. (required)
        :param str load_balancer: The loadBalancer to be retrieved. (required)
        :return: KeyValueTypeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_load_balancer_properties_with_http_info(server, load_balancer, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_properties_with_http_info(server, load_balancer, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_properties_with_http_info(self, server, load_balancer, **kwargs):  # noqa: E501
        """Get loadBalancer parameters  # noqa: E501

        Get loadBalancer parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_load_balancer_properties_with_http_info(server, load_balancer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the loadBalancer is added to. (required)
        :param str load_balancer: The loadBalancer to be retrieved. (required)
        :return: KeyValueTypeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'load_balancer']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_load_balancer_properties`")  # noqa: E501
        # verify the required parameter 'load_balancer' is set
        if ('load_balancer' not in params or
                params['load_balancer'] is None):
            raise ValueError("Missing the required parameter `load_balancer` when calling `get_load_balancer_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'load_balancer' in params:
            path_params['loadBalancer'] = params['load_balancer']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/loadbalancer/{loadBalancer}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KeyValueTypeListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_locked_external_users(self, **kwargs):  # noqa: E501
        """Get MFT locked external users.  # noqa: E501

        Get MFT locked external users.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_locked_external_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_locked_external_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_locked_external_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_locked_external_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get MFT locked external users.  # noqa: E501

        Get MFT locked external users.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_locked_external_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_locked_external_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externalusers/locked', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExternalUserData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_locked_external_users_for_site(self, site_name, **kwargs):  # noqa: E501
        """Get MFT locked external users for site.  # noqa: E501

        Get MFT locked external users for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_locked_external_users_for_site(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_locked_external_users_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_locked_external_users_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
            return data

    def get_locked_external_users_for_site_with_http_info(self, site_name, **kwargs):  # noqa: E501
        """Get MFT locked external users for site.  # noqa: E501

        Get MFT locked external users for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_locked_external_users_for_site_with_http_info(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :return: list[ExternalUserData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_locked_external_users_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_locked_external_users_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externalusers/locked', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExternalUserData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_configuration(self, server, agent, **kwargs):  # noqa: E501
        """Get MFT Configuration  # noqa: E501

        Get MFT Configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_configuration(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: MftConfigurationData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_configuration_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_configuration_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_mft_configuration_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """Get MFT Configuration  # noqa: E501

        Get MFT Configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_configuration_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: MftConfigurationData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_mft_configuration`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_mft_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MftConfigurationData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_folders(self, **kwargs):  # noqa: E501
        """Get MFT virtual folders that match the search criteria.  # noqa: E501

        Get MFT virtual folders that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_folders(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The virtual folder name.
        :return: list[FolderPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_folders_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_folders_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_mft_folders_with_http_info(self, **kwargs):  # noqa: E501
        """Get MFT virtual folders that match the search criteria.  # noqa: E501

        Get MFT virtual folders that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_folders_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The virtual folder name.
        :return: list[FolderPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_folders" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/virtualfolders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FolderPropertiesData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_folders_for_site(self, site_name, **kwargs):  # noqa: E501
        """Get MFT virtual folders that match the search criteria for site.  # noqa: E501

        Get MFT virtual folders that match the search criteria for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_folders_for_site(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: The virtual folder name.
        :return: list[FolderPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_folders_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_folders_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
            return data

    def get_mft_folders_for_site_with_http_info(self, site_name, **kwargs):  # noqa: E501
        """Get MFT virtual folders that match the search criteria for site.  # noqa: E501

        Get MFT virtual folders that match the search criteria for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_folders_for_site_with_http_info(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: The virtual folder name.
        :return: list[FolderPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_folders_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_mft_folders_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/virtualfolders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FolderPropertiesData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_gateways(self, **kwargs):  # noqa: E501
        """Get MFT gateways  # noqa: E501

        Get MFT gateways  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_gateways(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[GatewayData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_gateways_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_gateways_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_mft_gateways_with_http_info(self, **kwargs):  # noqa: E501
        """Get MFT gateways  # noqa: E501

        Get MFT gateways  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_gateways_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[GatewayData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_gateways" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/gateways', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GatewayData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_gateways_for_site(self, site_name, **kwargs):  # noqa: E501
        """Get MFT gateways for site  # noqa: E501

        Get MFT gateways for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_gateways_for_site(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :return: list[GatewayData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_gateways_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_gateways_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
            return data

    def get_mft_gateways_for_site_with_http_info(self, site_name, **kwargs):  # noqa: E501
        """Get MFT gateways for site  # noqa: E501

        Get MFT gateways for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_gateways_for_site_with_http_info(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :return: list[GatewayData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_gateways_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_mft_gateways_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/gateways', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GatewayData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_processing_rules_for_site(self, site_name, **kwargs):  # noqa: E501
        """Get MFTE processing rules that match the search criteria for site.  # noqa: E501

        Get MFTE processing rules that match the search criteria for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_processing_rules_for_site(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str name: The rule name.
        :param str description: The rule description.
        :param str priority: The rule priority.
        :param str status: The rule status.
        :return: list[RulePropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_processing_rules_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_processing_rules_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
            return data

    def get_mft_processing_rules_for_site_with_http_info(self, site_name, **kwargs):  # noqa: E501
        """Get MFTE processing rules that match the search criteria for site.  # noqa: E501

        Get MFTE processing rules that match the search criteria for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_processing_rules_for_site_with_http_info(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str name: The rule name.
        :param str description: The rule description.
        :param str priority: The rule priority.
        :param str status: The rule status.
        :return: list[RulePropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'name', 'description', 'priority', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_processing_rules_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_mft_processing_rules_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/processingRules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RulePropertiesData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_user_groups(self, **kwargs):  # noqa: E501
        """Get all user groups that match the search criteria.  # noqa: E501

        Get all user groups that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_user_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The user group name.
        :param str external_users: external users.
        :param str ldap_groups: ldap groups.
        :param str ldap_users: ldap users.
        :return: list[UserGroupPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_user_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_user_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_mft_user_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Get all user groups that match the search criteria.  # noqa: E501

        Get all user groups that match the search criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_user_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The user group name.
        :param str external_users: external users.
        :param str ldap_groups: ldap groups.
        :param str ldap_users: ldap users.
        :return: list[UserGroupPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'external_users', 'ldap_groups', 'ldap_users']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_user_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'external_users' in params:
            query_params.append(('externalUsers', params['external_users']))  # noqa: E501
        if 'ldap_groups' in params:
            query_params.append(('ldapGroups', params['ldap_groups']))  # noqa: E501
        if 'ldap_users' in params:
            query_params.append(('ldapUsers', params['ldap_users']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/usergroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserGroupPropertiesData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mft_user_groups_for_site(self, site_name, **kwargs):  # noqa: E501
        """Get all user groups that match the search criteria for site.  # noqa: E501

        Get all user groups that match the search criteria for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_user_groups_for_site(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: The user group name.
        :param str external_users: external users.
        :param str ldap_groups: ldap groups.
        :param str ldap_users: ldap users.
        :return: list[UserGroupPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_mft_user_groups_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mft_user_groups_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
            return data

    def get_mft_user_groups_for_site_with_http_info(self, site_name, **kwargs):  # noqa: E501
        """Get all user groups that match the search criteria for site.  # noqa: E501

        Get all user groups that match the search criteria for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mft_user_groups_for_site_with_http_info(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name. (required)
        :param str name: The user group name.
        :param str external_users: external users.
        :param str ldap_groups: ldap groups.
        :param str ldap_users: ldap users.
        :return: list[UserGroupPropertiesData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'name', 'external_users', 'ldap_groups', 'ldap_users']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mft_user_groups_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `get_mft_user_groups_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'external_users' in params:
            query_params.append(('externalUsers', params['external_users']))  # noqa: E501
        if 'ldap_groups' in params:
            query_params.append(('ldapGroups', params['ldap_groups']))  # noqa: E501
        if 'ldap_users' in params:
            query_params.append(('ldapUsers', params['ldap_users']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserGroupPropertiesData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_organization_group_user_simulation(self, user, **kwargs):  # noqa: E501
        """Get organization group user with authorization sumulation  # noqa: E501

        Get organization group user with authorization sumulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization_group_user_simulation(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: OrganizationGroupUserAuthorizationSimulationData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_organization_group_user_simulation_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_organization_group_user_simulation_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_organization_group_user_simulation_with_http_info(self, user, **kwargs):  # noqa: E501
        """Get organization group user with authorization sumulation  # noqa: E501

        Get organization group user with authorization sumulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization_group_user_simulation_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: OrganizationGroupUserAuthorizationSimulationData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization_group_user_simulation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_organization_group_user_simulation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/organizationgroup/{user}/simulate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationGroupUserAuthorizationSimulationData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pgp_templates(self, server, agent, **kwargs):  # noqa: E501
        """Get PGP Templates  # noqa: E501

        Get PGP Templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pgp_templates(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str name: The PGP Template Name
        :return: list[PgpTemplateData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pgp_templates_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pgp_templates_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_pgp_templates_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """Get PGP Templates  # noqa: E501

        Get PGP Templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pgp_templates_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str name: The PGP Template Name
        :return: list[PgpTemplateData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pgp_templates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_pgp_templates`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_pgp_templates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/pgptemplates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PgpTemplateData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_remote_host_properties(self, server, remotehost, **kwargs):  # noqa: E501
        """get a remote host configuration from Server  # noqa: E501

        Get the remote host configuration properties from the Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remote_host_properties(server, remotehost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host  is connected to. (required)
        :param str remotehost: The name of the remote host. (required)
        :return: AddRemoteHostParams
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_remote_host_properties_with_http_info(server, remotehost, **kwargs)  # noqa: E501
        else:
            (data) = self.get_remote_host_properties_with_http_info(server, remotehost, **kwargs)  # noqa: E501
            return data

    def get_remote_host_properties_with_http_info(self, server, remotehost, **kwargs):  # noqa: E501
        """get a remote host configuration from Server  # noqa: E501

        Get the remote host configuration properties from the Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remote_host_properties_with_http_info(server, remotehost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the remote host  is connected to. (required)
        :param str remotehost: The name of the remote host. (required)
        :return: AddRemoteHostParams
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'remotehost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remote_host_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_remote_host_properties`")  # noqa: E501
        # verify the required parameter 'remotehost' is set
        if ('remotehost' not in params or
                params['remotehost'] is None):
            raise ValueError("Missing the required parameter `remotehost` when calling `get_remote_host_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'remotehost' in params:
            path_params['remotehost'] = params['remotehost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/remotehost/{remotehost}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AddRemoteHostParams',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_remote_hosts(self, server, **kwargs):  # noqa: E501
        """get Server remote hosts  # noqa: E501

        Get all the remote hosts of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remote_hosts(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to query. (required)
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_remote_hosts_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_remote_hosts_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_remote_hosts_with_http_info(self, server, **kwargs):  # noqa: E501
        """get Server remote hosts  # noqa: E501

        Get all the remote hosts of the specified Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remote_hosts_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server to query. (required)
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remote_hosts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_remote_hosts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/remotehosts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role(self, role, **kwargs):  # noqa: E501
        """Get Authorization Role  # noqa: E501

        Get Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role(role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: The Role name. (required)
        :return: RoleData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_with_http_info(role, **kwargs)  # noqa: E501
        else:
            (data) = self.get_role_with_http_info(role, **kwargs)  # noqa: E501
            return data

    def get_role_with_http_info(self, role, **kwargs):  # noqa: E501
        """Get Authorization Role  # noqa: E501

        Get Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_with_http_info(role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: The Role name. (required)
        :return: RoleData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `get_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/role/{role}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoleData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role_associates(self, role, **kwargs):  # noqa: E501
        """Get all authorization entities associated with role  # noqa: E501

        Get all authorization entities associated with role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_associates(role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: role name. (required)
        :return: list[AssociateData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_associates_with_http_info(role, **kwargs)  # noqa: E501
        else:
            (data) = self.get_role_associates_with_http_info(role, **kwargs)  # noqa: E501
            return data

    def get_role_associates_with_http_info(self, role, **kwargs):  # noqa: E501
        """Get all authorization entities associated with role  # noqa: E501

        Get all authorization entities associated with role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_associates_with_http_info(role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role: role name. (required)
        :return: list[AssociateData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role_associates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `get_role_associates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/role/{role}/associates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AssociateData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_run_as_user(self, server, agent, user, **kwargs):  # noqa: E501
        """Get Run-as user  # noqa: E501

        Get Run-as user details from server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_run_as_user(server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :return: RunAsUserData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_run_as_user_with_http_info(server, agent, user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_run_as_user_with_http_info(server, agent, user, **kwargs)  # noqa: E501
            return data

    def get_run_as_user_with_http_info(self, server, agent, user, **kwargs):  # noqa: E501
        """Get Run-as user  # noqa: E501

        Get Run-as user details from server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_run_as_user_with_http_info(server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :return: RunAsUserData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_run_as_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_run_as_user`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_run_as_user`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_run_as_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/runasuser/{agent}/{user}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunAsUserData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_run_as_users_list(self, server, **kwargs):  # noqa: E501
        """Get Run-as user list that match the requested search criteria.  # noqa: E501

        Get Run-as user list that match the requested search criteria from server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_run_as_users_list(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str user: The Run-as user.
        :param str agent: The agent.
        :return: RunAsUsersList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_run_as_users_list_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_run_as_users_list_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_run_as_users_list_with_http_info(self, server, **kwargs):  # noqa: E501
        """Get Run-as user list that match the requested search criteria.  # noqa: E501

        Get Run-as user list that match the requested search criteria from server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_run_as_users_list_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str user: The Run-as user.
        :param str agent: The agent.
        :return: RunAsUsersList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'user', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_run_as_users_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_run_as_users_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501
        if 'agent' in params:
            query_params.append(('agent', params['agent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/runasusers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunAsUsersList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_server_definition(self, server, **kwargs):  # noqa: E501
        """Get Control-M/Server definition.  # noqa: E501

        Get the definition for this specific server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_definition(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: CtmServerDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_server_definition_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.get_server_definition_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def get_server_definition_with_http_info(self, server, **kwargs):  # noqa: E501
        """Get Control-M/Server definition.  # noqa: E501

        Get the definition for this specific server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_definition_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: CtmServerDefinition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_server_definition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_server_definition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/definition', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CtmServerDefinition',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_server_system_setting(self, **kwargs):  # noqa: E501
        """Get the Control-M server system settings  # noqa: E501

        Get the Control-M server system settings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_system_setting(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Server to obtain the system settings from, not required in Helix
        :param bool extended_data: True to return more agent parameters. HIDDEN
        :return: KeyValueListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_server_system_setting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_server_system_setting_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_server_system_setting_with_http_info(self, **kwargs):  # noqa: E501
        """Get the Control-M server system settings  # noqa: E501

        Get the Control-M server system settings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_system_setting_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Server to obtain the system settings from, not required in Helix
        :param bool extended_data: True to return more agent parameters. HIDDEN
        :return: KeyValueListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'extended_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_server_system_setting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'server' in params:
            query_params.append(('server', params['server']))  # noqa: E501
        if 'extended_data' in params:
            query_params.append(('extendedData', params['extended_data']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/systemsettings/server', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KeyValueListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_servers(self, **kwargs):  # noqa: E501
        """get all the Servers name and hostname in the system  # noqa: E501

        Get the names and hostnames of all Servers in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_servers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CtmDetailsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_servers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_servers_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_servers_with_http_info(self, **kwargs):  # noqa: E501
        """get all the Servers name and hostname in the system  # noqa: E501

        Get the names and hostnames of all Servers in the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_servers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CtmDetailsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_servers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CtmDetailsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ssh_key(self, ctm, key_name, pass_phrase, **kwargs):  # noqa: E501
        """Get public SSH key from the control-m server.  # noqa: E501

        Save the public key locally on your computer the public key should be transferred to the Agentless host A ssh key will be returned as a string that represent the key .  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ssh_key(ctm, key_name, pass_phrase, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param str key_name: The name for the key . REQUIRED. (required)
        :param str pass_phrase: The password for the key file . REQUIRED. (required)
        :return: SShPublicKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ssh_key_with_http_info(ctm, key_name, pass_phrase, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ssh_key_with_http_info(ctm, key_name, pass_phrase, **kwargs)  # noqa: E501
            return data

    def get_ssh_key_with_http_info(self, ctm, key_name, pass_phrase, **kwargs):  # noqa: E501
        """Get public SSH key from the control-m server.  # noqa: E501

        Save the public key locally on your computer the public key should be transferred to the Agentless host A ssh key will be returned as a string that represent the key .  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ssh_key_with_http_info(ctm, key_name, pass_phrase, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :param str key_name: The name for the key . REQUIRED. (required)
        :param str pass_phrase: The password for the key file . REQUIRED. (required)
        :return: SShPublicKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ctm', 'key_name', 'pass_phrase']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ssh_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `get_ssh_key`")  # noqa: E501
        # verify the required parameter 'key_name' is set
        if ('key_name' not in params or
                params['key_name'] is None):
            raise ValueError("Missing the required parameter `key_name` when calling `get_ssh_key`")  # noqa: E501
        # verify the required parameter 'pass_phrase' is set
        if ('pass_phrase' not in params or
                params['pass_phrase'] is None):
            raise ValueError("Missing the required parameter `pass_phrase` when calling `get_ssh_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501
        if 'key_name' in params:
            path_params['keyName'] = params['key_name']  # noqa: E501
        if 'pass_phrase' in params:
            path_params['passPhrase'] = params['pass_phrase']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/sshkey/{keyName}/{passPhrase}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SShPublicKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ssh_keys_list(self, ctm, **kwargs):  # noqa: E501
        """Get all will return full ssh data for all objects.  # noqa: E501

        Get all will return full ssh data for all objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ssh_keys_list(ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :return: list[SSHKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ssh_keys_list_with_http_info(ctm, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ssh_keys_list_with_http_info(ctm, **kwargs)  # noqa: E501
            return data

    def get_ssh_keys_list_with_http_info(self, ctm, **kwargs):  # noqa: E501
        """Get all will return full ssh data for all objects.  # noqa: E501

        Get all will return full ssh data for all objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ssh_keys_list_with_http_info(ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ctm: Name of the Control-M/Server. (required)
        :return: list[SSHKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ctm']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ssh_keys_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `get_ssh_keys_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/sshKeysList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SSHKey]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_system_setting(self, **kwargs):  # noqa: E501
        """Get system setting for Control-M environment  # noqa: E501

        Get system setting for Control-M environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_system_setting(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Server to which the system settings are applied
        :return: SystemSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_system_setting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_system_setting_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_system_setting_with_http_info(self, **kwargs):  # noqa: E501
        """Get system setting for Control-M environment  # noqa: E501

        Get system setting for Control-M environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_system_setting_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Server to which the system settings are applied
        :return: SystemSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_system_setting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'server' in params:
            query_params.append(('server', params['server']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/systemsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemSetting',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, user, **kwargs):  # noqa: E501
        """Get user  # noqa: E501

        Get user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: UserData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Get user  # noqa: E501

        Get user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: UserData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/{user}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_effective_rights(self, **kwargs):  # noqa: E501
        """Get user real effective authorizations  # noqa: E501

        Get user real effective authorizations by all his roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_effective_rights(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RoleData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_effective_rights_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_user_effective_rights_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_user_effective_rights_with_http_info(self, **kwargs):  # noqa: E501
        """Get user real effective authorizations  # noqa: E501

        Get user real effective authorizations by all his roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_effective_rights_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RoleData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_effective_rights" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/effectiveRights', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoleData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_simulation(self, user, **kwargs):  # noqa: E501
        """Get user with authorization sumulation  # noqa: E501

        Get user with authorization sumulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_simulation(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: UserData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_simulation_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_simulation_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def get_user_simulation_with_http_info(self, user, **kwargs):  # noqa: E501
        """Get user with authorization sumulation  # noqa: E501

        Get user with authorization sumulation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_simulation_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user name. (required)
        :return: UserData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_simulation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_user_simulation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/{user}/simulate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_wda_datasets(self, body, **kwargs):  # noqa: E501
        """Get datasets for specific connection profile.  # noqa: E501

        Get datasets for specific connection profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_wda_datasets(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WDADatasetInput body: Input for retrieving datasets. (required)
        :return: WDADatasetsAndSchemas
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_wda_datasets_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_wda_datasets_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def get_wda_datasets_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get datasets for specific connection profile.  # noqa: E501

        Get datasets for specific connection profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_wda_datasets_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WDADatasetInput body: Input for retrieving datasets. (required)
        :return: WDADatasetsAndSchemas
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_wda_datasets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_wda_datasets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/internal/dataAssurance/datasource/getDatasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WDADatasetsAndSchemas',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_wda_gateways(self, server, agent, **kwargs):  # noqa: E501
        """Get DataAssurance gateways  # noqa: E501

        Get DataAssurance gateways  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_wda_gateways(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: server name (required)
        :param str agent: agent name (required)
        :return: list[DataAssuranceGatewayData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_wda_gateways_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_wda_gateways_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_wda_gateways_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """Get DataAssurance gateways  # noqa: E501

        Get DataAssurance gateways  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_wda_gateways_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: server name (required)
        :param str agent: agent name (required)
        :return: list[DataAssuranceGatewayData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_wda_gateways" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_wda_gateways`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_wda_gateways`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/dataAssurance/{server}/{agent}/gateways', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DataAssuranceGatewayData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workflow_insights_data_export_status(self, **kwargs):  # noqa: E501
        """Get workflow data export status.  # noqa: E501

        Get workflow data export status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_insights_data_export_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: WorkflowInsightsDataExportStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workflow_insights_data_export_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_workflow_insights_data_export_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_workflow_insights_data_export_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get workflow data export status.  # noqa: E501

        Get workflow data export status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_insights_data_export_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: WorkflowInsightsDataExportStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_insights_data_export_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/workflowinsights/dataexport/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkflowInsightsDataExportStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workflow_insights_data_export_system_params(self, **kwargs):  # noqa: E501
        """Get workflow data export system parameters.  # noqa: E501

        Get workflow data export system parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_insights_data_export_system_params(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemParametersList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workflow_insights_data_export_system_params_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_workflow_insights_data_export_system_params_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_workflow_insights_data_export_system_params_with_http_info(self, **kwargs):  # noqa: E501
        """Get workflow data export system parameters.  # noqa: E501

        Get workflow data export system parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_insights_data_export_system_params_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemParametersList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_insights_data_export_system_params" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/workflowinsights/dataexport/parameters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemParametersList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workflow_insights_status(self, **kwargs):  # noqa: E501
        """get Workflow Insights status  # noqa: E501

        get Workflow Insights status - topology and system parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_insights_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: WorkflowInsightsStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workflow_insights_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_workflow_insights_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_workflow_insights_status_with_http_info(self, **kwargs):  # noqa: E501
        """get Workflow Insights status  # noqa: E501

        get Workflow Insights status - topology and system parameters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_insights_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: WorkflowInsightsStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_insights_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/workflowinsights/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkflowInsightsStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_zos_templates(self, server, agent, **kwargs):  # noqa: E501
        """Get z/OS Templates  # noqa: E501

        Get z/OS Templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_zos_templates(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str name: The z/OS Template Name
        :return: list[ZosTemplateData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_zos_templates_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.get_zos_templates_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def get_zos_templates_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """Get z/OS Templates  # noqa: E501

        Get z/OS Templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_zos_templates_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str name: The z/OS Template Name
        :return: list[ZosTemplateData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_zos_templates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `get_zos_templates`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `get_zos_templates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/zostemplates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ZosTemplateData]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_secrets(self, **kwargs):  # noqa: E501
        """Get list of secret names  # noqa: E501

        Get the list of names of all the secrets in the vault  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_secrets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_secrets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_secrets_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_secrets_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of secret names  # noqa: E501

        Get the list of names of all the secrets in the vault  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_secrets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StringListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_secrets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/secrets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def lock_external_user(self, user_name, **kwargs):  # noqa: E501
        """Lock external user  # noqa: E501

        Lock an existing external user in MFTE  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_external_user(user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.lock_external_user_with_http_info(user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.lock_external_user_with_http_info(user_name, **kwargs)  # noqa: E501
            return data

    def lock_external_user_with_http_info(self, user_name, **kwargs):  # noqa: E501
        """Lock external user  # noqa: E501

        Lock an existing external user in MFTE  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_external_user_with_http_info(user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method lock_external_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `lock_external_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_name' in params:
            path_params['userName'] = params['user_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externaluser/{userName}/lock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def lock_external_user_for_site(self, site_name, user_name, **kwargs):  # noqa: E501
        """Lock external user for site  # noqa: E501

        Lock an existing external user in MFTE for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_external_user_for_site(site_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.lock_external_user_for_site_with_http_info(site_name, user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.lock_external_user_for_site_with_http_info(site_name, user_name, **kwargs)  # noqa: E501
            return data

    def lock_external_user_for_site_with_http_info(self, site_name, user_name, **kwargs):  # noqa: E501
        """Lock external user for site  # noqa: E501

        Lock an existing external user in MFTE for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.lock_external_user_for_site_with_http_info(site_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'user_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method lock_external_user_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `lock_external_user_for_site`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `lock_external_user_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'user_name' in params:
            path_params['userName'] = params['user_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externaluser/{userName}/lock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def managed_ctm_server(self, server, host, port, **kwargs):  # noqa: E501
        """Set server to managed state.  # noqa: E501

        Set server to managed state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.managed_ctm_server(server, host, port, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param str host: Server host. (required)
        :param str port: Server port. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.managed_ctm_server_with_http_info(server, host, port, **kwargs)  # noqa: E501
        else:
            (data) = self.managed_ctm_server_with_http_info(server, host, port, **kwargs)  # noqa: E501
            return data

    def managed_ctm_server_with_http_info(self, server, host, port, **kwargs):  # noqa: E501
        """Set server to managed state.  # noqa: E501

        Set server to managed state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.managed_ctm_server_with_http_info(server, host, port, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param str host: Server host. (required)
        :param str port: Server port. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'host', 'port']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method managed_ctm_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `managed_ctm_server`")  # noqa: E501
        # verify the required parameter 'host' is set
        if ('host' not in params or
                params['host'] is None):
            raise ValueError("Missing the required parameter `host` when calling `managed_ctm_server`")  # noqa: E501
        # verify the required parameter 'port' is set
        if ('port' not in params or
                params['port'] is None):
            raise ValueError("Missing the required parameter `port` when calling `managed_ctm_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []
        if 'host' in params:
            query_params.append(('host', params['host']))  # noqa: E501
        if 'port' in params:
            query_params.append(('port', params['port']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/managed', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def perform_em_failover(self, **kwargs):  # noqa: E501
        """Perform EM failover to the secondary EM server  # noqa: E501

        Perform EM failover to the secondary EM server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.perform_em_failover(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.perform_em_failover_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.perform_em_failover_with_http_info(**kwargs)  # noqa: E501
            return data

    def perform_em_failover_with_http_info(self, **kwargs):  # noqa: E501
        """Perform EM failover to the secondary EM server  # noqa: E501

        Perform EM failover to the secondary EM server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.perform_em_failover_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method perform_em_failover" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/em/failover', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def perform_em_fallback(self, **kwargs):  # noqa: E501
        """Perform EM fallback to the primary EM server  # noqa: E501

        Perform EM fallback to the primary EM server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.perform_em_fallback(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.perform_em_fallback_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.perform_em_fallback_with_http_info(**kwargs)  # noqa: E501
            return data

    def perform_em_fallback_with_http_info(self, **kwargs):  # noqa: E501
        """Perform EM fallback to the primary EM server  # noqa: E501

        Perform EM fallback to the primary EM server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.perform_em_fallback_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method perform_em_fallback" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/em/fallback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ping_agent(self, server, agent, **kwargs):  # noqa: E501
        """ping to the agent in the Server  # noqa: E501

        Ping an Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_agent(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :param PingAgentParams body:
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ping_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.ping_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def ping_agent_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """ping to the agent in the Server  # noqa: E501

        Ping an Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_agent_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent. (required)
        :param PingAgentParams body:
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `ping_agent`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `ping_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ping_agentless_host(self, server, agentlesshost, **kwargs):  # noqa: E501
        """ping to the agentless host in the Server  # noqa: E501

        Ping an Agentless Host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_agentless_host(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agentlesshost: The Agentless Host. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ping_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.ping_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def ping_agentless_host_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """ping to the agentless host in the Server  # noqa: E501

        Ping an Agentless Host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_agentless_host_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agentlesshost: The Agentless Host. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping_agentless_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `ping_agentless_host`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `ping_agentless_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def poll_add_ssh_key_request_by_polling_id(self, polling_id, **kwargs):  # noqa: E501
        """Polling request for async Add an SSH key to the control-m server.  # noqa: E501

        Polling request used to poll previous Add an SSH key to the control-m server requests by polling id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.poll_add_ssh_key_request_by_polling_id(polling_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str polling_id: The request's returned polling ID valid for this session only. (required)
        :return: AddSshKeyPollingResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.poll_add_ssh_key_request_by_polling_id_with_http_info(polling_id, **kwargs)  # noqa: E501
        else:
            (data) = self.poll_add_ssh_key_request_by_polling_id_with_http_info(polling_id, **kwargs)  # noqa: E501
            return data

    def poll_add_ssh_key_request_by_polling_id_with_http_info(self, polling_id, **kwargs):  # noqa: E501
        """Polling request for async Add an SSH key to the control-m server.  # noqa: E501

        Polling request used to poll previous Add an SSH key to the control-m server requests by polling id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.poll_add_ssh_key_request_by_polling_id_with_http_info(polling_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str polling_id: The request's returned polling ID valid for this session only. (required)
        :return: AddSshKeyPollingResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['polling_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method poll_add_ssh_key_request_by_polling_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'polling_id' is set
        if ('polling_id' not in params or
                params['polling_id'] is None):
            raise ValueError("Missing the required parameter `polling_id` when calling `poll_add_ssh_key_request_by_polling_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'polling_id' in params:
            path_params['pollingId'] = params['polling_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/sshkey/add/polling/{pollingId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AddSshKeyPollingResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recycle_item(self, id, **kwargs):  # noqa: E501
        """recycle item  # noqa: E501

        Recycle an item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recycle_item(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: item data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recycle_item_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.recycle_item_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def recycle_item_with_http_info(self, id, **kwargs):  # noqa: E501
        """recycle item  # noqa: E501

        Recycle an item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recycle_item_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: item data (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recycle_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `recycle_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/item/{id}/recycle', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_server_system_settings(self, server, **kwargs):  # noqa: E501
        """Refresh the Control-M server system settings  # noqa: E501

        Refresh the Control-M server system settings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_server_system_settings(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The server for which system settings need to be refreshed (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_server_system_settings_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.refresh_server_system_settings_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def refresh_server_system_settings_with_http_info(self, server, **kwargs):  # noqa: E501
        """Refresh the Control-M server system settings  # noqa: E501

        Refresh the Control-M server system settings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_server_system_settings_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The server for which system settings need to be refreshed (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_server_system_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `refresh_server_system_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/systemsettings/server/{server}/refresh', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_controlm_server(self, server, **kwargs):  # noqa: E501
        """Delete Server  # noqa: E501

        Delete Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_controlm_server(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Server host name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_controlm_server_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_controlm_server_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def remove_controlm_server_with_http_info(self, server, **kwargs):  # noqa: E501
        """Delete Server  # noqa: E501

        Delete Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_controlm_server_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Server host name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_controlm_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `remove_controlm_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_ctm_gateway(self, server, gtw_host_name, **kwargs):  # noqa: E501
        """Delete gateway  # noqa: E501

        Delete gateway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_ctm_gateway(server, gtw_host_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Control-M/Server host (required)
        :param str gtw_host_name: Gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_ctm_gateway_with_http_info(server, gtw_host_name, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_ctm_gateway_with_http_info(server, gtw_host_name, **kwargs)  # noqa: E501
            return data

    def remove_ctm_gateway_with_http_info(self, server, gtw_host_name, **kwargs):  # noqa: E501
        """Delete gateway  # noqa: E501

        Delete gateway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_ctm_gateway_with_http_info(server, gtw_host_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Control-M/Server host (required)
        :param str gtw_host_name: Gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'gtw_host_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_ctm_gateway" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `remove_ctm_gateway`")  # noqa: E501
        # verify the required parameter 'gtw_host_name' is set
        if ('gtw_host_name' not in params or
                params['gtw_host_name'] is None):
            raise ValueError("Missing the required parameter `gtw_host_name` when calling `remove_ctm_gateway`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'gtw_host_name' in params:
            path_params['gtwHostName'] = params['gtw_host_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/gateway/{gtwHostName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_gateway(self, gateway_name, **kwargs):  # noqa: E501
        """remove gateway.  # noqa: E501

        remove gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_gateway(gateway_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str gateway_name: gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_gateway_with_http_info(gateway_name, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_gateway_with_http_info(gateway_name, **kwargs)  # noqa: E501
            return data

    def remove_gateway_with_http_info(self, gateway_name, **kwargs):  # noqa: E501
        """remove gateway.  # noqa: E501

        remove gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_gateway_with_http_info(gateway_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str gateway_name: gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gateway_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_gateway" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gateway_name' is set
        if ('gateway_name' not in params or
                params['gateway_name'] is None):
            raise ValueError("Missing the required parameter `gateway_name` when calling `remove_gateway`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gateway_name' in params:
            path_params['gatewayName'] = params['gateway_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/gateway/{gatewayName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_gateway_for_site(self, site_name, gateway_name, **kwargs):  # noqa: E501
        """remove gateway for site.  # noqa: E501

        remove gateway for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_gateway_for_site(site_name, gateway_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str gateway_name: gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_gateway_for_site_with_http_info(site_name, gateway_name, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_gateway_for_site_with_http_info(site_name, gateway_name, **kwargs)  # noqa: E501
            return data

    def remove_gateway_for_site_with_http_info(self, site_name, gateway_name, **kwargs):  # noqa: E501
        """remove gateway for site.  # noqa: E501

        remove gateway for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_gateway_for_site_with_http_info(site_name, gateway_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str gateway_name: gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'gateway_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_gateway_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `remove_gateway_for_site`")  # noqa: E501
        # verify the required parameter 'gateway_name' is set
        if ('gateway_name' not in params or
                params['gateway_name'] is None):
            raise ValueError("Missing the required parameter `gateway_name` when calling `remove_gateway_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'gateway_name' in params:
            path_params['gatewayName'] = params['gateway_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/gateway/{gatewayName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_hub_from_cluster(self, agentname, **kwargs):  # noqa: E501
        """remove hub from cluster.  # noqa: E501

        remove hub from cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_hub_from_cluster(agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_hub_from_cluster_with_http_info(agentname, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_hub_from_cluster_with_http_info(agentname, **kwargs)  # noqa: E501
            return data

    def remove_hub_from_cluster_with_http_info(self, agentname, **kwargs):  # noqa: E501
        """remove hub from cluster.  # noqa: E501

        remove hub from cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_hub_from_cluster_with_http_info(agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['agentname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_hub_from_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'agentname' is set
        if ('agentname' not in params or
                params['agentname'] is None):
            raise ValueError("Missing the required parameter `agentname` when calling `remove_hub_from_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'agentname' in params:
            path_params['agentname'] = params['agentname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/cluster/hub/{agentname}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_hub_from_cluster_for_site(self, site_name, agentname, **kwargs):  # noqa: E501
        """remove hub from cluster for site.  # noqa: E501

        remove hub from cluster for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_hub_from_cluster_for_site(site_name, agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_hub_from_cluster_for_site_with_http_info(site_name, agentname, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_hub_from_cluster_for_site_with_http_info(site_name, agentname, **kwargs)  # noqa: E501
            return data

    def remove_hub_from_cluster_for_site_with_http_info(self, site_name, agentname, **kwargs):  # noqa: E501
        """remove hub from cluster for site.  # noqa: E501

        remove hub from cluster for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_hub_from_cluster_for_site_with_http_info(site_name, agentname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: site name (required)
        :param str agentname: Agent name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'agentname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_hub_from_cluster_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `remove_hub_from_cluster_for_site`")  # noqa: E501
        # verify the required parameter 'agentname' is set
        if ('agentname' not in params or
                params['agentname'] is None):
            raise ValueError("Missing the required parameter `agentname` when calling `remove_hub_from_cluster_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'agentname' in params:
            path_params['agentname'] = params['agentname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/cluster/hub/{agentname}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_role_from_user(self, user, role, **kwargs):  # noqa: E501
        """Remove a role from a user  # noqa: E501

        Remove a role from a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_role_from_user(user, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Name of user (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_role_from_user_with_http_info(user, role, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_role_from_user_with_http_info(user, role, **kwargs)  # noqa: E501
            return data

    def remove_role_from_user_with_http_info(self, user, role, **kwargs):  # noqa: E501
        """Remove a role from a user  # noqa: E501

        Remove a role from a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_role_from_user_with_http_info(user, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Name of user (required)
        :param str role: Name of role (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_role_from_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `remove_role_from_user`")  # noqa: E501
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `remove_role_from_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/{user}/role/{role}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_wda_gateway(self, server, agent, gateway_name, **kwargs):  # noqa: E501
        """remove DataAssurance gateway.  # noqa: E501

        remove DataAssurance gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_wda_gateway(server, agent, gateway_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: server name (required)
        :param str agent: agent name (required)
        :param str gateway_name: DataAssurance gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_wda_gateway_with_http_info(server, agent, gateway_name, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_wda_gateway_with_http_info(server, agent, gateway_name, **kwargs)  # noqa: E501
            return data

    def remove_wda_gateway_with_http_info(self, server, agent, gateway_name, **kwargs):  # noqa: E501
        """remove DataAssurance gateway.  # noqa: E501

        remove DataAssurance gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_wda_gateway_with_http_info(server, agent, gateway_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: server name (required)
        :param str agent: agent name (required)
        :param str gateway_name: DataAssurance gateway name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'gateway_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_wda_gateway" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `remove_wda_gateway`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `remove_wda_gateway`")  # noqa: E501
        # verify the required parameter 'gateway_name' is set
        if ('gateway_name' not in params or
                params['gateway_name'] is None):
            raise ValueError("Missing the required parameter `gateway_name` when calling `remove_wda_gateway`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'gateway_name' in params:
            path_params['gatewayName'] = params['gateway_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/dataAssurance/{server}/{agent}/gateway/{gatewayName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rename_role(self, body, role, **kwargs):  # noqa: E501
        """Rename Authorization Role  # noqa: E501

        Rename Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_role(body, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RoleProperties body: The new role name. (required)
        :param str role: The Role name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.rename_role_with_http_info(body, role, **kwargs)  # noqa: E501
        else:
            (data) = self.rename_role_with_http_info(body, role, **kwargs)  # noqa: E501
            return data

    def rename_role_with_http_info(self, body, role, **kwargs):  # noqa: E501
        """Rename Authorization Role  # noqa: E501

        Rename Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_role_with_http_info(body, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RoleProperties body: The new role name. (required)
        :param str role: The Role name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rename_role`")  # noqa: E501
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `rename_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/role/{role}/rename', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replicate_database(self, server, **kwargs):  # noqa: E501
        """Trigger DB replication For CTM High Availability  # noqa: E501

        Trigger DB replication on a specified Server For CTM High Availability  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replicate_database(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replicate_database_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.replicate_database_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def replicate_database_with_http_info(self, server, **kwargs):  # noqa: E501
        """Trigger DB replication For CTM High Availability  # noqa: E501

        Trigger DB replication on a specified Server For CTM High Availability  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replicate_database_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replicate_database" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `replicate_database`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/database/replicate', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resume_ctm(self, server, **kwargs):  # noqa: E501
        """Resume the CTM server.  # noqa: E501

        When server is resumed, the server is still up and running but do not execute new jobs. Any jobs that are already executing will continue to be.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_ctm(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resume_ctm_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.resume_ctm_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def resume_ctm_with_http_info(self, server, **kwargs):  # noqa: E501
        """Resume the CTM server.  # noqa: E501

        When server is resumed, the server is still up and running but do not execute new jobs. Any jobs that are already executing will continue to be.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_ctm_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_ctm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `resume_ctm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/resume', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def send_archive_cleanup_request(self, **kwargs):  # noqa: E501
        """Deletes data (jobs including outputs and logs) from the Workload Archiving database.  # noqa: E501

        Deletes data (jobs including outputs and logs) by search criteria from the Workload Archiving database.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_archive_cleanup_request(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: Job's application.
        :param str application_exceptions: Cleanup should skip job's application that are mentioned in exceptions
        :param str sub_application: Job's sub application
        :param str sub_application_exceptions: Job's sub application exception
        :param str ctm: server name
        :param str server: Server name
        :param str ctm_exceptions: server exceptions
        :param str server_exceptions: Server exceptions
        :param str folder: Job's folder.
        :param str folder_exceptions: Job's folder exceptions
        :param str jobname: Job's name
        :param str jobname_exceptions: Job's name exceptions
        :param str library: Job's library
        :param str library_exceptions: Job's library exceptions
        :param str rule_name: Job's archive rule
        :param str job_status: The job's end status.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.send_archive_cleanup_request_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.send_archive_cleanup_request_with_http_info(**kwargs)  # noqa: E501
            return data

    def send_archive_cleanup_request_with_http_info(self, **kwargs):  # noqa: E501
        """Deletes data (jobs including outputs and logs) from the Workload Archiving database.  # noqa: E501

        Deletes data (jobs including outputs and logs) by search criteria from the Workload Archiving database.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_archive_cleanup_request_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application: Job's application.
        :param str application_exceptions: Cleanup should skip job's application that are mentioned in exceptions
        :param str sub_application: Job's sub application
        :param str sub_application_exceptions: Job's sub application exception
        :param str ctm: server name
        :param str server: Server name
        :param str ctm_exceptions: server exceptions
        :param str server_exceptions: Server exceptions
        :param str folder: Job's folder.
        :param str folder_exceptions: Job's folder exceptions
        :param str jobname: Job's name
        :param str jobname_exceptions: Job's name exceptions
        :param str library: Job's library
        :param str library_exceptions: Job's library exceptions
        :param str rule_name: Job's archive rule
        :param str job_status: The job's end status.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application', 'application_exceptions', 'sub_application', 'sub_application_exceptions', 'ctm', 'server', 'ctm_exceptions', 'server_exceptions', 'folder', 'folder_exceptions', 'jobname', 'jobname_exceptions', 'library', 'library_exceptions', 'rule_name', 'job_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_archive_cleanup_request" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application' in params:
            query_params.append(('application', params['application']))  # noqa: E501
        if 'application_exceptions' in params:
            query_params.append(('applicationExceptions', params['application_exceptions']))  # noqa: E501
        if 'sub_application' in params:
            query_params.append(('subApplication', params['sub_application']))  # noqa: E501
        if 'sub_application_exceptions' in params:
            query_params.append(('subApplicationExceptions', params['sub_application_exceptions']))  # noqa: E501
        if 'ctm' in params:
            query_params.append(('ctm', params['ctm']))  # noqa: E501
        if 'server' in params:
            query_params.append(('server', params['server']))  # noqa: E501
        if 'ctm_exceptions' in params:
            query_params.append(('ctmExceptions', params['ctm_exceptions']))  # noqa: E501
        if 'server_exceptions' in params:
            query_params.append(('serverExceptions', params['server_exceptions']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'folder_exceptions' in params:
            query_params.append(('folderExceptions', params['folder_exceptions']))  # noqa: E501
        if 'jobname' in params:
            query_params.append(('jobname', params['jobname']))  # noqa: E501
        if 'jobname_exceptions' in params:
            query_params.append(('jobnameExceptions', params['jobname_exceptions']))  # noqa: E501
        if 'library' in params:
            query_params.append(('library', params['library']))  # noqa: E501
        if 'library_exceptions' in params:
            query_params.append(('libraryExceptions', params['library_exceptions']))  # noqa: E501
        if 'rule_name' in params:
            query_params.append(('ruleName', params['rule_name']))  # noqa: E501
        if 'job_status' in params:
            query_params.append(('jobStatus', params['job_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/archive/cleanup', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_active_shout_destination_list(self, server, listname, **kwargs):  # noqa: E501
        """Activates the notification destinations list.  # noqa: E501

        Activates the notification destinations list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_active_shout_destination_list(server, listname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Defines the name of the Server. (required)
        :param str listname: Defines the name of the notification destinations list. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_active_shout_destination_list_with_http_info(server, listname, **kwargs)  # noqa: E501
        else:
            (data) = self.set_active_shout_destination_list_with_http_info(server, listname, **kwargs)  # noqa: E501
            return data

    def set_active_shout_destination_list_with_http_info(self, server, listname, **kwargs):  # noqa: E501
        """Activates the notification destinations list.  # noqa: E501

        Activates the notification destinations list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_active_shout_destination_list_with_http_info(server, listname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: Defines the name of the Server. (required)
        :param str listname: Defines the name of the notification destinations list. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'listname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_active_shout_destination_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `set_active_shout_destination_list`")  # noqa: E501
        # verify the required parameter 'listname' is set
        if ('listname' not in params or
                params['listname'] is None):
            raise ValueError("Missing the required parameter `listname` when calling `set_active_shout_destination_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'listname' in params:
            path_params['listname'] = params['listname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/notification/list/{listname}/setactive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_agent_parameter(self, server, agent, name, **kwargs):  # noqa: E501
        """set agent parameter  # noqa: E501

        Set the value of the specified parameter in the specified agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_agent_parameter(server, agent, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to update. (required)
        :param str name: The parameter name. (required)
        :param OptionalValue body: The new parameter value.
        :return: KeyValue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_agent_parameter_with_http_info(server, agent, name, **kwargs)  # noqa: E501
        else:
            (data) = self.set_agent_parameter_with_http_info(server, agent, name, **kwargs)  # noqa: E501
            return data

    def set_agent_parameter_with_http_info(self, server, agent, name, **kwargs):  # noqa: E501
        """set agent parameter  # noqa: E501

        Set the value of the specified parameter in the specified agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_agent_parameter_with_http_info(server, agent, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to update. (required)
        :param str name: The parameter name. (required)
        :param OptionalValue body: The new parameter value.
        :return: KeyValue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_agent_parameter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `set_agent_parameter`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `set_agent_parameter`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `set_agent_parameter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/param/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KeyValue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_ctm_desired_state(self, server, state, **kwargs):  # noqa: E501
        """Set server to desired state.  # noqa: E501

        Set server to desired state - Up, Down, Recycle, Ignore.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_ctm_desired_state(server, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param str state: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_ctm_desired_state_with_http_info(server, state, **kwargs)  # noqa: E501
        else:
            (data) = self.set_ctm_desired_state_with_http_info(server, state, **kwargs)  # noqa: E501
            return data

    def set_ctm_desired_state_with_http_info(self, server, state, **kwargs):  # noqa: E501
        """Set server to desired state.  # noqa: E501

        Set server to desired state - Up, Down, Recycle, Ignore.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_ctm_desired_state_with_http_info(server, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param str state: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_ctm_desired_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `set_ctm_desired_state`")  # noqa: E501
        # verify the required parameter 'state' is set
        if ('state' not in params or
                params['state'] is None):
            raise ValueError("Missing the required parameter `state` when calling `set_ctm_desired_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'state' in params:
            path_params['state'] = params['state']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/desiredState/{state}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_em_as_primary(self, **kwargs):  # noqa: E501
        """Set the secondary EM server as Primary  # noqa: E501

        Set the secondary EM server as Primary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_em_as_primary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_em_as_primary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.set_em_as_primary_with_http_info(**kwargs)  # noqa: E501
            return data

    def set_em_as_primary_with_http_info(self, **kwargs):  # noqa: E501
        """Set the secondary EM server as Primary  # noqa: E501

        Set the secondary EM server as Primary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_em_as_primary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_em_as_primary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/em/setasprimary', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_server_system_setting(self, name, value, **kwargs):  # noqa: E501
        """Set a system setting for Control-M server  # noqa: E501

        Set a system setting for Control-M server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_server_system_setting(name, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Parameter name (required)
        :param str value: Parameter value (required)
        :param str server: Server to set the system settings.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_server_system_setting_with_http_info(name, value, **kwargs)  # noqa: E501
        else:
            (data) = self.set_server_system_setting_with_http_info(name, value, **kwargs)  # noqa: E501
            return data

    def set_server_system_setting_with_http_info(self, name, value, **kwargs):  # noqa: E501
        """Set a system setting for Control-M server  # noqa: E501

        Set a system setting for Control-M server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_server_system_setting_with_http_info(name, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Parameter name (required)
        :param str value: Parameter value (required)
        :param str server: Server to set the system settings.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'value', 'server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_server_system_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `set_server_system_setting`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `set_server_system_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'value' in params:
            path_params['value'] = params['value']  # noqa: E501

        query_params = []
        if 'server' in params:
            query_params.append(('server', params['server']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/systemsettings/server/{name}/{value}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_system_param(self, body, name, **kwargs):  # noqa: E501
        """set value of a an em system parameter  # noqa: E501

        Set value of an enterprise management system parameter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_system_param(body, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Value body: Param new value (required)
        :param str name: Parameter name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_system_param_with_http_info(body, name, **kwargs)  # noqa: E501
        else:
            (data) = self.set_system_param_with_http_info(body, name, **kwargs)  # noqa: E501
            return data

    def set_system_param_with_http_info(self, body, name, **kwargs):  # noqa: E501
        """set value of a an em system parameter  # noqa: E501

        Set value of an enterprise management system parameter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_system_param_with_http_info(body, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Value body: Param new value (required)
        :param str name: Parameter name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_system_param" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_system_param`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `set_system_param`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/em/param/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_system_setting(self, systemsetting, saml2metadatafile, **kwargs):  # noqa: E501
        """Set system setting for Control-M environment  # noqa: E501

        Set system setting for Control-M environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_system_setting(systemsetting, saml2metadatafile, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str systemsetting: (required)
        :param str saml2metadatafile: (required)
        :param str server: Server to which the system settings are applied
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_system_setting_with_http_info(systemsetting, saml2metadatafile, **kwargs)  # noqa: E501
        else:
            (data) = self.set_system_setting_with_http_info(systemsetting, saml2metadatafile, **kwargs)  # noqa: E501
            return data

    def set_system_setting_with_http_info(self, systemsetting, saml2metadatafile, **kwargs):  # noqa: E501
        """Set system setting for Control-M environment  # noqa: E501

        Set system setting for Control-M environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_system_setting_with_http_info(systemsetting, saml2metadatafile, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str systemsetting: (required)
        :param str saml2metadatafile: (required)
        :param str server: Server to which the system settings are applied
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['systemsetting', 'saml2metadatafile', 'server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_system_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'systemsetting' is set
        if ('systemsetting' not in params or
                params['systemsetting'] is None):
            raise ValueError("Missing the required parameter `systemsetting` when calling `set_system_setting`")  # noqa: E501
        # verify the required parameter 'saml2metadatafile' is set
        if ('saml2metadatafile' not in params or
                params['saml2metadatafile'] is None):
            raise ValueError("Missing the required parameter `saml2metadatafile` when calling `set_system_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'server' in params:
            query_params.append(('server', params['server']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'systemsetting' in params:
            local_var_files['systemsetting'] = params['systemsetting']  # noqa: E501
        if 'saml2metadatafile' in params:
            local_var_files['saml2metadatafile'] = params['saml2metadatafile']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/systemsettings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_user_preferences(self, body, user_name, **kwargs):  # noqa: E501
        """Set user preferences by user name  # noqa: E501

        Set user preferences by user name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_user_preferences(body, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserPreferences body: The new value of UserPreferences to set (required)
        :param str user_name: The name of the user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_user_preferences_with_http_info(body, user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.set_user_preferences_with_http_info(body, user_name, **kwargs)  # noqa: E501
            return data

    def set_user_preferences_with_http_info(self, body, user_name, **kwargs):  # noqa: E501
        """Set user preferences by user name  # noqa: E501

        Set user preferences by user name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_user_preferences_with_http_info(body, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserPreferences body: The new value of UserPreferences to set (required)
        :param str user_name: The name of the user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_user_preferences" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_user_preferences`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `set_user_preferences`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_name' in params:
            query_params.append(('userName', params['user_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/preferences', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_workflow_insights_data_export_system_params(self, body, **kwargs):  # noqa: E501
        """set workflow data export system parameters.  # noqa: E501

        set workflow data export system parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_workflow_insights_data_export_system_params(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SystemParametersList body: workflow data export system parameters. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_workflow_insights_data_export_system_params_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_workflow_insights_data_export_system_params_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def set_workflow_insights_data_export_system_params_with_http_info(self, body, **kwargs):  # noqa: E501
        """set workflow data export system parameters.  # noqa: E501

        set workflow data export system parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_workflow_insights_data_export_system_params_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SystemParametersList body: workflow data export system parameters. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_workflow_insights_data_export_system_params" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_workflow_insights_data_export_system_params`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/workflowinsights/dataexport/parameters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def setasprimary(self, server, **kwargs):  # noqa: E501
        """Set secondary server as Primary on a specified Server  # noqa: E501

        Set secondary server as Primary on a specified Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.setasprimary(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.setasprimary_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.setasprimary_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def setasprimary_with_http_info(self, server, **kwargs):  # noqa: E501
        """Set secondary server as Primary on a specified Server  # noqa: E501

        Set secondary server as Primary on a specified Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.setasprimary_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method setasprimary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `setasprimary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/setasprimary', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_agent(self, server, agent, **kwargs):  # noqa: E501
        """Test the Agent connectivity to the server.  # noqa: E501

        allows the user to test the Agent connectivity before adding it to his environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_agent(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is going to be tested to. (required)
        :param str agent: The agent is going to be tested. (required)
        :param SetAgentParamsList body: The non default, advanced configuration data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.test_agent_with_http_info(server, agent, **kwargs)  # noqa: E501
            return data

    def test_agent_with_http_info(self, server, agent, **kwargs):  # noqa: E501
        """Test the Agent connectivity to the server.  # noqa: E501

        allows the user to test the Agent connectivity before adding it to his environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_agent_with_http_info(server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server the agent is going to be tested to. (required)
        :param str agent: The agent is going to be tested. (required)
        :param SetAgentParamsList body: The non default, advanced configuration data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `test_agent`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `test_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_agentless_host(self, server, agentlesshost, **kwargs):  # noqa: E501
        """test Agentless Host in the Server  # noqa: E501

        Test an Agentless Host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_agentless_host(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agentlesshost: The Agentless Host. (required)
        :param AgentlessHostDetails body: The agentless host data.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.test_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def test_agentless_host_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """test Agentless Host in the Server  # noqa: E501

        Test an Agentless Host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_agentless_host_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agentlesshost: The Agentless Host. (required)
        :param AgentlessHostDetails body: The agentless host data.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_agentless_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `test_agentless_host`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `test_agentless_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_run_as_user(self, server, agent, user, **kwargs):  # noqa: E501
        """Test existed Run-as user  # noqa: E501

        Test existing Run-as user in server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_run_as_user(server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :param RunAsUserDetailsData body: Run as user details data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_run_as_user_with_http_info(server, agent, user, **kwargs)  # noqa: E501
        else:
            (data) = self.test_run_as_user_with_http_info(server, agent, user, **kwargs)  # noqa: E501
            return data

    def test_run_as_user_with_http_info(self, server, agent, user, **kwargs):  # noqa: E501
        """Test existed Run-as user  # noqa: E501

        Test existing Run-as user in server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_run_as_user_with_http_info(server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :param RunAsUserDetailsData body: Run as user details data
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agent', 'user', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_run_as_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `test_run_as_user`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `test_run_as_user`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `test_run_as_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/runasuser/{agent}/{user}/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlock_external_user(self, user_name, **kwargs):  # noqa: E501
        """Unlock an external user  # noqa: E501

        Unlock an existing external user in MFTE  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_user(user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlock_external_user_with_http_info(user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.unlock_external_user_with_http_info(user_name, **kwargs)  # noqa: E501
            return data

    def unlock_external_user_with_http_info(self, user_name, **kwargs):  # noqa: E501
        """Unlock an external user  # noqa: E501

        Unlock an existing external user in MFTE  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_user_with_http_info(user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlock_external_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `unlock_external_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_name' in params:
            path_params['userName'] = params['user_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externaluser/{userName}/unlock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlock_external_user_for_site(self, site_name, user_name, **kwargs):  # noqa: E501
        """Unlock an external user for site  # noqa: E501

        Unlock an existing external user in MFTE for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_user_for_site(site_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlock_external_user_for_site_with_http_info(site_name, user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.unlock_external_user_for_site_with_http_info(site_name, user_name, **kwargs)  # noqa: E501
            return data

    def unlock_external_user_for_site_with_http_info(self, site_name, user_name, **kwargs):  # noqa: E501
        """Unlock an external user for site  # noqa: E501

        Unlock an existing external user in MFTE for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_user_for_site_with_http_info(site_name, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :param str user_name: Name of external user (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name', 'user_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlock_external_user_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `unlock_external_user_for_site`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `unlock_external_user_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'user_name' in params:
            path_params['userName'] = params['user_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externaluser/{userName}/unlock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlock_external_users(self, **kwargs):  # noqa: E501
        """Unlock all external users  # noqa: E501

        Unlock all existing external users in MFTE  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlock_external_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.unlock_external_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def unlock_external_users_with_http_info(self, **kwargs):  # noqa: E501
        """Unlock all external users  # noqa: E501

        Unlock all existing external users in MFTE  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlock_external_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externalusers/unlock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlock_external_users_for_site(self, site_name, **kwargs):  # noqa: E501
        """Unlock all external users for site  # noqa: E501

        Unlock all existing external users in MFTE for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_users_for_site(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlock_external_users_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
        else:
            (data) = self.unlock_external_users_for_site_with_http_info(site_name, **kwargs)  # noqa: E501
            return data

    def unlock_external_users_for_site_with_http_info(self, site_name, **kwargs):  # noqa: E501
        """Unlock all external users for site  # noqa: E501

        Unlock all existing external users in MFTE for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_external_users_for_site_with_http_info(site_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str site_name: The site name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['site_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlock_external_users_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `unlock_external_users_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externalusers/unlock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unmanaged_ctm_server(self, server, **kwargs):  # noqa: E501
        """Set server to unmanaged state.  # noqa: E501

        Set server to unmanaged state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unmanaged_ctm_server(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param str host: Server host
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unmanaged_ctm_server_with_http_info(server, **kwargs)  # noqa: E501
        else:
            (data) = self.unmanaged_ctm_server_with_http_info(server, **kwargs)  # noqa: E501
            return data

    def unmanaged_ctm_server_with_http_info(self, server, **kwargs):  # noqa: E501
        """Set server to unmanaged state.  # noqa: E501

        Set server to unmanaged state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unmanaged_ctm_server_with_http_info(server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: (required)
        :param str host: Server host
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'host']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unmanaged_ctm_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `unmanaged_ctm_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []
        if 'host' in params:
            query_params.append(('host', params['host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/unmanaged', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_agent_parameter(self, body, server, agent, **kwargs):  # noqa: E501
        """Update agent parameter  # noqa: E501

        Update a parameter for a specified Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_agent_parameter(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param KeyValueObject body: The parameter to be updated. (required)
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to query. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_agent_parameter_with_http_info(body, server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.update_agent_parameter_with_http_info(body, server, agent, **kwargs)  # noqa: E501
            return data

    def update_agent_parameter_with_http_info(self, body, server, agent, **kwargs):  # noqa: E501
        """Update agent parameter  # noqa: E501

        Update a parameter for a specified Agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_agent_parameter_with_http_info(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param KeyValueObject body: The parameter to be updated. (required)
        :param str server: The Server the agent is connected to. (required)
        :param str agent: The name of the agent to query. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_agent_parameter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_agent_parameter`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_agent_parameter`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `update_agent_parameter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_agentless_host(self, server, agentlesshost, **kwargs):  # noqa: E501
        """Update agentless host  # noqa: E501

        Update agentless host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_agentless_host(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The server the agentless host is connected to. (required)
        :param str agentlesshost: The agentless host to update. (required)
        :param AgentlessHostDetails body: The agentless host data to update.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
        else:
            (data) = self.update_agentless_host_with_http_info(server, agentlesshost, **kwargs)  # noqa: E501
            return data

    def update_agentless_host_with_http_info(self, server, agentlesshost, **kwargs):  # noqa: E501
        """Update agentless host  # noqa: E501

        Update agentless host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_agentless_host_with_http_info(server, agentlesshost, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str server: The server the agentless host is connected to. (required)
        :param str agentlesshost: The agentless host to update. (required)
        :param AgentlessHostDetails body: The agentless host data to update.
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server', 'agentlesshost', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_agentless_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_agentless_host`")  # noqa: E501
        # verify the required parameter 'agentlesshost' is set
        if ('agentlesshost' not in params or
                params['agentlesshost'] is None):
            raise ValueError("Missing the required parameter `agentlesshost` when calling `update_agentless_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agentlesshost' in params:
            path_params['agentlesshost'] = params['agentlesshost']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agentlesshost/{agentlesshost}/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_archive_rule(self, body, rule_name, **kwargs):  # noqa: E501
        """Edit Workload Archiving rule  # noqa: E501

        Edit Workload Archiving rule details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_archive_rule(body, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ArchiveRule body: Edit Workload Archiving rule details (required)
        :param str rule_name: Rule name to update (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_archive_rule_with_http_info(body, rule_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_archive_rule_with_http_info(body, rule_name, **kwargs)  # noqa: E501
            return data

    def update_archive_rule_with_http_info(self, body, rule_name, **kwargs):  # noqa: E501
        """Edit Workload Archiving rule  # noqa: E501

        Edit Workload Archiving rule details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_archive_rule_with_http_info(body, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ArchiveRule body: Edit Workload Archiving rule details (required)
        :param str rule_name: Rule name to update (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'rule_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_archive_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_archive_rule`")  # noqa: E501
        # verify the required parameter 'rule_name' is set
        if ('rule_name' not in params or
                params['rule_name'] is None):
            raise ValueError("Missing the required parameter `rule_name` when calling `update_archive_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_name' in params:
            path_params['ruleName'] = params['rule_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/archive/rule/{ruleName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ctm_gateway(self, body, **kwargs):  # noqa: E501
        """Update gateway.  # noqa: E501

        Update an existing gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ctm_gateway(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateGatewayParams body: Parameters for updating the gateway (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ctm_gateway_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ctm_gateway_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def update_ctm_gateway_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update gateway.  # noqa: E501

        Update an existing gateway.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ctm_gateway_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateGatewayParams body: Parameters for updating the gateway (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ctm_gateway" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_ctm_gateway`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/gateway', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_external_user(self, body, username, **kwargs):  # noqa: E501
        """Update an external user  # noqa: E501

        Update an external user for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_external_user(body, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :param str username: The external user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_external_user_with_http_info(body, username, **kwargs)  # noqa: E501
        else:
            (data) = self.update_external_user_with_http_info(body, username, **kwargs)  # noqa: E501
            return data

    def update_external_user_with_http_info(self, body, username, **kwargs):  # noqa: E501
        """Update an external user  # noqa: E501

        Update an external user for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_external_user_with_http_info(body, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :param str username: The external user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'username']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_external_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_external_user`")  # noqa: E501
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `update_external_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/externaluser/{username}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_external_user_for_site(self, body, site_name, username, **kwargs):  # noqa: E501
        """Update an external user for site  # noqa: E501

        Update an external user for site for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_external_user_for_site(body, site_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :param str site_name: site name (required)
        :param str username: The external user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_external_user_for_site_with_http_info(body, site_name, username, **kwargs)  # noqa: E501
        else:
            (data) = self.update_external_user_for_site_with_http_info(body, site_name, username, **kwargs)  # noqa: E501
            return data

    def update_external_user_for_site_with_http_info(self, body, site_name, username, **kwargs):  # noqa: E501
        """Update an external user for site  # noqa: E501

        Update an external user for site for b2b  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_external_user_for_site_with_http_info(body, site_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalUserData body: External user data (required)
        :param str site_name: site name (required)
        :param str username: The external user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_name', 'username']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_external_user_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_external_user_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `update_external_user_for_site`")  # noqa: E501
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `update_external_user_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'username' in params:
            path_params['username'] = params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/externaluser/{username}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_fts_settings(self, body, server, agent, **kwargs):  # noqa: E501
        """Update File Transfer Server (FTS) configuration data.  # noqa: E501

        Update File Transfer Server (FTS) configuration data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_fts_settings(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FtsSettingsData body: File Transfer Server (FTS) configuration data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_fts_settings_with_http_info(body, server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.update_fts_settings_with_http_info(body, server, agent, **kwargs)  # noqa: E501
            return data

    def update_fts_settings_with_http_info(self, body, server, agent, **kwargs):  # noqa: E501
        """Update File Transfer Server (FTS) configuration data.  # noqa: E501

        Update File Transfer Server (FTS) configuration data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_fts_settings_with_http_info(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FtsSettingsData body: File Transfer Server (FTS) configuration data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_fts_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_fts_settings`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_fts_settings`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `update_fts_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/fts/settings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_host_restriction(self, body, ctm, **kwargs):  # noqa: E501
        """Update an Host Restriction in the control-m server.  # noqa: E501

        Update an Host Restriction in the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_host_restriction(body, ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HostRestriction body: The parameters of the host restriction nodePrefix maxJobsAllowed maxCPUPct. (required)
        :param str ctm: Name of the Control-M/Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_host_restriction_with_http_info(body, ctm, **kwargs)  # noqa: E501
        else:
            (data) = self.update_host_restriction_with_http_info(body, ctm, **kwargs)  # noqa: E501
            return data

    def update_host_restriction_with_http_info(self, body, ctm, **kwargs):  # noqa: E501
        """Update an Host Restriction in the control-m server.  # noqa: E501

        Update an Host Restriction in the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_host_restriction_with_http_info(body, ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HostRestriction body: The parameters of the host restriction nodePrefix maxJobsAllowed maxCPUPct. (required)
        :param str ctm: Name of the Control-M/Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ctm']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_host_restriction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_host_restriction`")  # noqa: E501
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `update_host_restriction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/hostRestriction', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_hosts_in_hostgroup(self, body, server, hostgroup, **kwargs):  # noqa: E501
        """update agents in hostgroup.  # noqa: E501

        update agents in hostgroup.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_hosts_in_hostgroup(body, server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HostgroupProperties body: Agent list to update in a hostgroup (required)
        :param str server: The Server the agent is connected to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_hosts_in_hostgroup_with_http_info(body, server, hostgroup, **kwargs)  # noqa: E501
        else:
            (data) = self.update_hosts_in_hostgroup_with_http_info(body, server, hostgroup, **kwargs)  # noqa: E501
            return data

    def update_hosts_in_hostgroup_with_http_info(self, body, server, hostgroup, **kwargs):  # noqa: E501
        """update agents in hostgroup.  # noqa: E501

        update agents in hostgroup.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_hosts_in_hostgroup_with_http_info(body, server, hostgroup, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HostgroupProperties body: Agent list to update in a hostgroup (required)
        :param str server: The Server the agent is connected to. (required)
        :param str hostgroup: The hostgroup name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'hostgroup']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_hosts_in_hostgroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_hosts_in_hostgroup`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_hosts_in_hostgroup`")  # noqa: E501
        # verify the required parameter 'hostgroup' is set
        if ('hostgroup' not in params or
                params['hostgroup'] is None):
            raise ValueError("Missing the required parameter `hostgroup` when calling `update_hosts_in_hostgroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'hostgroup' in params:
            path_params['hostgroup'] = params['hostgroup']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/hostgroup/{hostgroup}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer(self, body, server, load_balancer, **kwargs):  # noqa: E501
        """update loadBalancer  # noqa: E501

        Update an existing loadBalancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer(body, server, load_balancer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetAgentParamsList body: The parameters list. (required)
        :param str server: The Server the loadBalncer is going to be added to. (required)
        :param str load_balancer: The loadbalncer to be updated. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_load_balancer_with_http_info(body, server, load_balancer, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_with_http_info(body, server, load_balancer, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_with_http_info(self, body, server, load_balancer, **kwargs):  # noqa: E501
        """update loadBalancer  # noqa: E501

        Update an existing loadBalancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_load_balancer_with_http_info(body, server, load_balancer, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetAgentParamsList body: The parameters list. (required)
        :param str server: The Server the loadBalncer is going to be added to. (required)
        :param str load_balancer: The loadbalncer to be updated. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'load_balancer']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_load_balancer`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_load_balancer`")  # noqa: E501
        # verify the required parameter 'load_balancer' is set
        if ('load_balancer' not in params or
                params['load_balancer'] is None):
            raise ValueError("Missing the required parameter `load_balancer` when calling `update_load_balancer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'load_balancer' in params:
            path_params['loadBalancer'] = params['load_balancer']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/loadbalancer/{loadBalancer}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mft_configuration(self, body, server, agent, **kwargs):  # noqa: E501
        """Update MFT Configuration  # noqa: E501

        Update MFT Configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_configuration(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MftConfigurationData body: MFT Configuration Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_mft_configuration_with_http_info(body, server, agent, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mft_configuration_with_http_info(body, server, agent, **kwargs)  # noqa: E501
            return data

    def update_mft_configuration_with_http_info(self, body, server, agent, **kwargs):  # noqa: E501
        """Update MFT Configuration  # noqa: E501

        Update MFT Configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_configuration_with_http_info(body, server, agent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MftConfigurationData body: MFT Configuration Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mft_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_mft_configuration`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_mft_configuration`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `update_mft_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/configuration', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mft_folder(self, body, folder_name, **kwargs):  # noqa: E501
        """Update an existing virtual folder in MFT.  # noqa: E501

        Update an existing virtual folder in MFT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_folder(body, folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_mft_folder_with_http_info(body, folder_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mft_folder_with_http_info(body, folder_name, **kwargs)  # noqa: E501
            return data

    def update_mft_folder_with_http_info(self, body, folder_name, **kwargs):  # noqa: E501
        """Update an existing virtual folder in MFT.  # noqa: E501

        Update an existing virtual folder in MFT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_folder_with_http_info(body, folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'folder_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mft_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_mft_folder`")  # noqa: E501
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `update_mft_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/virtualfolder/{folderName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mft_folder_for_site(self, body, site_name, folder_name, **kwargs):  # noqa: E501
        """Update an existing virtual folder in MFT for site.  # noqa: E501

        Update an existing virtual folder in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_folder_for_site(body, site_name, folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_mft_folder_for_site_with_http_info(body, site_name, folder_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mft_folder_for_site_with_http_info(body, site_name, folder_name, **kwargs)  # noqa: E501
            return data

    def update_mft_folder_for_site_with_http_info(self, body, site_name, folder_name, **kwargs):  # noqa: E501
        """Update an existing virtual folder in MFT for site.  # noqa: E501

        Update an existing virtual folder in MFT for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_folder_for_site_with_http_info(body, site_name, folder_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FolderPropertiesData body: virtual folder data (required)
        :param str site_name: The site name. (required)
        :param str folder_name: Name of folder (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_name', 'folder_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mft_folder_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `update_mft_folder_for_site`")  # noqa: E501
        # verify the required parameter 'folder_name' is set
        if ('folder_name' not in params or
                params['folder_name'] is None):
            raise ValueError("Missing the required parameter `folder_name` when calling `update_mft_folder_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'folder_name' in params:
            path_params['folderName'] = params['folder_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/virtualfolder/{folderName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mft_processing_rule_for_site(self, rule_properties_file, site_name, rule_name, **kwargs):  # noqa: E501
        """Update MFTE processing rule for site  # noqa: E501

        Update MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_processing_rule_for_site(rule_properties_file, site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_properties_file: (required)
        :param str site_name: site name (required)
        :param str rule_name: processing rule name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_mft_processing_rule_for_site_with_http_info(rule_properties_file, site_name, rule_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mft_processing_rule_for_site_with_http_info(rule_properties_file, site_name, rule_name, **kwargs)  # noqa: E501
            return data

    def update_mft_processing_rule_for_site_with_http_info(self, rule_properties_file, site_name, rule_name, **kwargs):  # noqa: E501
        """Update MFTE processing rule for site  # noqa: E501

        Update MFTE processing rule for site  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_processing_rule_for_site_with_http_info(rule_properties_file, site_name, rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_properties_file: (required)
        :param str site_name: site name (required)
        :param str rule_name: processing rule name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_properties_file', 'site_name', 'rule_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mft_processing_rule_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_properties_file' is set
        if ('rule_properties_file' not in params or
                params['rule_properties_file'] is None):
            raise ValueError("Missing the required parameter `rule_properties_file` when calling `update_mft_processing_rule_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `update_mft_processing_rule_for_site`")  # noqa: E501
        # verify the required parameter 'rule_name' is set
        if ('rule_name' not in params or
                params['rule_name'] is None):
            raise ValueError("Missing the required parameter `rule_name` when calling `update_mft_processing_rule_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'rule_name' in params:
            path_params['ruleName'] = params['rule_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'rule_properties_file' in params:
            local_var_files['rulePropertiesFile'] = params['rule_properties_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/processingRule/{ruleName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mft_user_group(self, body, name, **kwargs):  # noqa: E501
        """Update user group.  # noqa: E501

        Update user group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_user_group(body, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupDetailsData body: User group details (required)
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_mft_user_group_with_http_info(body, name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mft_user_group_with_http_info(body, name, **kwargs)  # noqa: E501
            return data

    def update_mft_user_group_with_http_info(self, body, name, **kwargs):  # noqa: E501
        """Update user group.  # noqa: E501

        Update user group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_user_group_with_http_info(body, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupDetailsData body: User group details (required)
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mft_user_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_mft_user_group`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_mft_user_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mft/usergroup/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mft_user_group_for_site(self, body, site_name, name, **kwargs):  # noqa: E501
        """Update user group for site.  # noqa: E501

        Update user group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_user_group_for_site(body, site_name, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupDetailsData body: User group details (required)
        :param str site_name: The site name. (required)
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_mft_user_group_for_site_with_http_info(body, site_name, name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mft_user_group_for_site_with_http_info(body, site_name, name, **kwargs)  # noqa: E501
            return data

    def update_mft_user_group_for_site_with_http_info(self, body, site_name, name, **kwargs):  # noqa: E501
        """Update user group for site.  # noqa: E501

        Update user group for site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_mft_user_group_for_site_with_http_info(body, site_name, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroupDetailsData body: User group details (required)
        :param str site_name: The site name. (required)
        :param str name: User group name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'site_name', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mft_user_group_for_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'site_name' is set
        if ('site_name' not in params or
                params['site_name'] is None):
            raise ValueError("Missing the required parameter `site_name` when calling `update_mft_user_group_for_site`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_mft_user_group_for_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'site_name' in params:
            path_params['siteName'] = params['site_name']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/mfte/site/{siteName}/usergroup/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_pgp_template(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Update PGP Template  # noqa: E501

        Update PGP Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_pgp_template(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PgpTemplateData body: PGP Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The PGP Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_pgp_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_pgp_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
            return data

    def update_pgp_template_with_http_info(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Update PGP Template  # noqa: E501

        Update PGP Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_pgp_template_with_http_info(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PgpTemplateData body: PGP Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The PGP Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent', 'template_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_pgp_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_pgp_template`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_pgp_template`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `update_pgp_template`")  # noqa: E501
        # verify the required parameter 'template_name' is set
        if ('template_name' not in params or
                params['template_name'] is None):
            raise ValueError("Missing the required parameter `template_name` when calling `update_pgp_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'template_name' in params:
            path_params['templateName'] = params['template_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/pgptemplate/{templateName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_role(self, role_file, role, **kwargs):  # noqa: E501
        """Update Authorization Role  # noqa: E501

        Update Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role(role_file, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role_file: (required)
        :param str role: The Role name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_role_with_http_info(role_file, role, **kwargs)  # noqa: E501
        else:
            (data) = self.update_role_with_http_info(role_file, role, **kwargs)  # noqa: E501
            return data

    def update_role_with_http_info(self, role_file, role, **kwargs):  # noqa: E501
        """Update Authorization Role  # noqa: E501

        Update Authorization Role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role_with_http_info(role_file, role, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str role_file: (required)
        :param str role: The Role name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['role_file', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'role_file' is set
        if ('role_file' not in params or
                params['role_file'] is None):
            raise ValueError("Missing the required parameter `role_file` when calling `update_role`")  # noqa: E501
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `update_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'role' in params:
            path_params['role'] = params['role']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'role_file' in params:
            local_var_files['roleFile'] = params['role_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/role/{role}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_run_as_user(self, body, server, agent, user, **kwargs):  # noqa: E501
        """Update Run-as user  # noqa: E501

        Update Run-as user details in server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_as_user(body, server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunAsUserDetailsData body: Run as user details data (required)
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_run_as_user_with_http_info(body, server, agent, user, **kwargs)  # noqa: E501
        else:
            (data) = self.update_run_as_user_with_http_info(body, server, agent, user, **kwargs)  # noqa: E501
            return data

    def update_run_as_user_with_http_info(self, body, server, agent, user, **kwargs):  # noqa: E501
        """Update Run-as user  # noqa: E501

        Update Run-as user details in server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_run_as_user_with_http_info(body, server, agent, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RunAsUserDetailsData body: Run as user details data (required)
        :param str server: The Server. (required)
        :param str agent: The Agent (required)
        :param str user: The user name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_run_as_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_run_as_user`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_run_as_user`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `update_run_as_user`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `update_run_as_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/runasuser/{agent}/{user}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_secret(self, name, **kwargs):  # noqa: E501
        """Update an existing secret  # noqa: E501

        Update an existing secret in the secrets vault.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_secret(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of the secret to update (required)
        :param SecretValue body: The new value for the secret
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_secret_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_secret_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def update_secret_with_http_info(self, name, **kwargs):  # noqa: E501
        """Update an existing secret  # noqa: E501

        Update an existing secret in the secrets vault.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_secret_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of the secret to update (required)
        :param SecretValue body: The new value for the secret
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_secret`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/secret/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_server(self, body, server, **kwargs):  # noqa: E501
        """Update Server  # noqa: E501

        Update Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_server(body, server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServerEditParams body: (required)
        :param str server: Server host name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_server_with_http_info(body, server, **kwargs)  # noqa: E501
        else:
            (data) = self.update_server_with_http_info(body, server, **kwargs)  # noqa: E501
            return data

    def update_server_with_http_info(self, body, server, **kwargs):  # noqa: E501
        """Update Server  # noqa: E501

        Update Server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_server_with_http_info(body, server, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServerEditParams body: (required)
        :param str server: Server host name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_server`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ssh_key(self, body, ctm, **kwargs):  # noqa: E501
        """Update an SSH key in the control-m server.  # noqa: E501

        Update an SSH key in the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ssh_key(body, ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SSHKeyData body: The parameters of the ssh key name password type format bits. (required)
        :param str ctm: Name of the Control-M/Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ssh_key_with_http_info(body, ctm, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ssh_key_with_http_info(body, ctm, **kwargs)  # noqa: E501
            return data

    def update_ssh_key_with_http_info(self, body, ctm, **kwargs):  # noqa: E501
        """Update an SSH key in the control-m server.  # noqa: E501

        Update an SSH key in the control-m server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ssh_key_with_http_info(body, ctm, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SSHKeyData body: The parameters of the ssh key name password type format bits. (required)
        :param str ctm: Name of the Control-M/Server. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'ctm']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ssh_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_ssh_key`")  # noqa: E501
        # verify the required parameter 'ctm' is set
        if ('ctm' not in params or
                params['ctm'] is None):
            raise ValueError("Missing the required parameter `ctm` when calling `update_ssh_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ctm' in params:
            path_params['ctm'] = params['ctm']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{ctm}/sshkey/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, user_file, user, **kwargs):  # noqa: E501
        """Update user  # noqa: E501

        Update user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(user_file, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_file: (required)
        :param str user: The user name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_with_http_info(user_file, user, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(user_file, user, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, user_file, user, **kwargs):  # noqa: E501
        """Update user  # noqa: E501

        Update user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(user_file, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_file: (required)
        :param str user: The user name. (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_file', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_file' is set
        if ('user_file' not in params or
                params['user_file'] is None):
            raise ValueError("Missing the required parameter `user_file` when calling `update_user`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'user_file' in params:
            local_var_files['userFile'] = params['user_file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/authorization/user/{user}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_zos_template(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Update z/OS Template  # noqa: E501

        Update z/OS Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_zos_template(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ZosTemplateData body: z/OS Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The z/OS Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_zos_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_zos_template_with_http_info(body, server, agent, template_name, **kwargs)  # noqa: E501
            return data

    def update_zos_template_with_http_info(self, body, server, agent, template_name, **kwargs):  # noqa: E501
        """Update z/OS Template  # noqa: E501

        Update z/OS Template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_zos_template_with_http_info(body, server, agent, template_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ZosTemplateData body: z/OS Template Data (required)
        :param str server: The Server (required)
        :param str agent: The Agent (required)
        :param str template_name: The z/OS Template Name (required)
        :return: SuccessData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'server', 'agent', 'template_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_zos_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_zos_template`")  # noqa: E501
        # verify the required parameter 'server' is set
        if ('server' not in params or
                params['server'] is None):
            raise ValueError("Missing the required parameter `server` when calling `update_zos_template`")  # noqa: E501
        # verify the required parameter 'agent' is set
        if ('agent' not in params or
                params['agent'] is None):
            raise ValueError("Missing the required parameter `agent` when calling `update_zos_template`")  # noqa: E501
        # verify the required parameter 'template_name' is set
        if ('template_name' not in params or
                params['template_name'] is None):
            raise ValueError("Missing the required parameter `template_name` when calling `update_zos_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server' in params:
            path_params['server'] = params['server']  # noqa: E501
        if 'agent' in params:
            path_params['agent'] = params['agent']  # noqa: E501
        if 'template_name' in params:
            path_params['templateName'] = params['template_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/config/server/{server}/agent/{agent}/mft/zostemplate/{templateName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
